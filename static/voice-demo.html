<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Elektro-Notdienst</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Core palette - Industrial Dark */
            --bg-primary: #0a0c0f;
            --bg-secondary: #12151a;
            --bg-tertiary: #1a1e25;
            --bg-elevated: #22272f;

            /* Borders */
            --border-subtle: rgba(255, 255, 255, 0.06);
            --border-default: rgba(255, 255, 255, 0.1);

            /* Text */
            --text-primary: #f0f2f5;
            --text-secondary: #9ca3af;
            --text-muted: #6b7280;
            --text-inverse: #0a0c0f;

            /* Accents */
            --amber-400: #fbbf24;
            --amber-500: #f59e0b;
            --amber-600: #d97706;
            --amber-glow: rgba(251, 191, 36, 0.15);

            --cyan-400: #22d3ee;
            --cyan-500: #06b6d4;
            --cyan-glow: rgba(6, 182, 212, 0.2);

            --emerald-400: #34d399;
            --emerald-500: #10b981;
            --emerald-glow: rgba(16, 185, 129, 0.15);

            --rose-400: #fb7185;
            --rose-500: #f43f5e;
            --rose-glow: rgba(244, 63, 94, 0.15);

            /* Typography */
            --font-sans: 'IBM Plex Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-mono: 'JetBrains Mono', monospace;

            /* Spacing */
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;
            --space-5: 20px;
            --space-6: 24px;

            /* Radii */
            --radius-sm: 6px;
            --radius-md: 10px;
            --radius-lg: 14px;
            --radius-xl: 20px;
            --radius-full: 50%;

            /* Transitions */
            --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-base: 200ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: var(--font-sans);
            background: var(--bg-primary);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            -webkit-font-smoothing: antialiased;
        }

        /* Subtle grid pattern */
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
            z-index: -1;
        }

        /* Header */
        .header {
            padding: var(--space-4) var(--space-5);
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }

        .brand-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--amber-500), var(--amber-600));
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.3);
        }

        .brand-text {
            display: flex;
            flex-direction: column;
        }

        .brand-title {
            font-size: 1.1rem;
            font-weight: 700;
            letter-spacing: -0.02em;
        }

        .brand-subtitle {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .status-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border-radius: 20px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: var(--radius-full);
            background: var(--emerald-400);
            animation: pulse-glow 2s ease-in-out infinite;
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 0 0 rgba(52, 211, 153, 0.5); }
            50% { box-shadow: 0 0 0 8px rgba(52, 211, 153, 0); }
        }

        /* Chat area */
        .chat-area {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-4);
            display: flex;
            flex-direction: column;
            gap: var(--space-3);
            -webkit-overflow-scrolling: touch;
        }

        .message {
            max-width: 85%;
            padding: var(--space-3) var(--space-4);
            border-radius: var(--radius-lg);
            font-size: 0.95rem;
            line-height: 1.5;
            animation: message-in 0.3s ease-out;
        }

        @keyframes message-in {
            from { opacity: 0; transform: translateY(12px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.user {
            align-self: flex-end;
            background: linear-gradient(135deg, var(--amber-500), var(--amber-600));
            color: var(--text-inverse);
            border-bottom-right-radius: var(--radius-sm);
        }

        .message.assistant {
            align-self: flex-start;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-subtle);
            border-bottom-left-radius: var(--radius-sm);
        }

        .message.system {
            align-self: center;
            background: var(--bg-secondary);
            border: 1px solid var(--border-subtle);
            font-size: 0.85rem;
            text-align: center;
            color: var(--text-secondary);
            padding: var(--space-3);
        }

        .message.job-created {
            align-self: center;
            background: linear-gradient(135deg, var(--emerald-500), #059669);
            color: white;
            text-align: center;
            padding: var(--space-5);
            max-width: 90%;
            border-radius: var(--radius-lg);
        }

        .job-success-icon {
            font-size: 2.5rem;
            margin-bottom: var(--space-2);
        }

        .job-success-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .job-success-number {
            font-family: var(--font-mono);
            font-size: 0.9rem;
            opacity: 0.9;
            margin-bottom: var(--space-2);
        }

        .job-success-meta {
            font-size: 0.8rem;
            opacity: 0.85;
        }

        .message.error {
            align-self: center;
            background: var(--rose-glow);
            border: 1px solid var(--rose-500);
            color: var(--rose-400);
        }

        /* Quick actions */
        .quick-actions {
            display: flex;
            gap: var(--space-2);
            padding: var(--space-3) var(--space-4);
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-subtle);
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .quick-btn {
            flex-shrink: 0;
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 10px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: 24px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .quick-btn:active {
            transform: scale(0.97);
            background: var(--bg-elevated);
        }

        .quick-btn-icon {
            font-size: 1.1rem;
        }

        /* Mic area */
        .mic-area {
            padding: var(--space-5);
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-subtle);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-4);
        }

        .speaking-indicator {
            display: none;
            align-items: center;
            gap: var(--space-2);
            padding: 8px 16px;
            background: var(--cyan-glow);
            border-radius: 20px;
            font-size: 0.85rem;
            color: var(--cyan-400);
        }

        .speaking-indicator.active {
            display: flex;
        }

        .speaking-waves {
            display: flex;
            gap: 3px;
            height: 18px;
            align-items: center;
        }

        .speaking-wave {
            width: 3px;
            background: var(--cyan-400);
            border-radius: 2px;
            animation: wave 1s ease-in-out infinite;
        }

        .speaking-wave:nth-child(1) { animation-delay: 0s; height: 8px; }
        .speaking-wave:nth-child(2) { animation-delay: 0.1s; height: 14px; }
        .speaking-wave:nth-child(3) { animation-delay: 0.2s; height: 18px; }
        .speaking-wave:nth-child(4) { animation-delay: 0.3s; height: 14px; }
        .speaking-wave:nth-child(5) { animation-delay: 0.4s; height: 8px; }

        @keyframes wave {
            0%, 100% { transform: scaleY(1); }
            50% { transform: scaleY(0.4); }
        }

        .transcript-preview {
            min-height: 20px;
            font-size: 0.85rem;
            color: var(--text-muted);
            text-align: center;
            font-style: italic;
        }

        .mic-button {
            width: 88px;
            height: 88px;
            border-radius: var(--radius-full);
            border: none;
            background: linear-gradient(135deg, var(--rose-500), #dc2626);
            color: white;
            font-size: 2.2rem;
            cursor: pointer;
            transition: all var(--transition-base);
            box-shadow: 0 4px 24px rgba(244, 63, 94, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mic-button:active {
            transform: scale(0.95);
        }

        .mic-button.recording {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            animation: mic-pulse 1.5s ease-in-out infinite;
        }

        @keyframes mic-pulse {
            0% { box-shadow: 0 0 0 0 rgba(244, 63, 94, 0.6); }
            50% { box-shadow: 0 0 0 20px rgba(244, 63, 94, 0); }
            100% { box-shadow: 0 0 0 0 rgba(244, 63, 94, 0); }
        }

        .mic-hint {
            font-size: 0.85rem;
            color: var(--text-muted);
            text-align: center;
        }

        .mic-hint.recording {
            color: var(--rose-400);
            font-weight: 500;
        }

        /* Info form overlay */
        .info-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(10, 12, 15, 0.95);
            backdrop-filter: blur(8px);
            z-index: 100;
            padding: var(--space-5);
            overflow-y: auto;
        }

        .info-overlay.active {
            display: block;
        }

        .info-form {
            max-width: 400px;
            margin: 0 auto;
            padding-top: 20px;
        }

        .form-header {
            text-align: center;
            margin-bottom: var(--space-6);
        }

        .form-header-icon {
            width: 56px;
            height: 56px;
            background: var(--amber-glow);
            border-radius: var(--radius-lg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            margin: 0 auto var(--space-3);
        }

        .form-header h2 {
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .form-header p {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .form-group {
            margin-bottom: var(--space-4);
        }

        .form-group label {
            display: block;
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .form-group input {
            width: 100%;
            padding: 14px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-md);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 1rem;
            transition: all var(--transition-fast);
        }

        .form-group input::placeholder {
            color: var(--text-muted);
        }

        .form-group input:focus {
            outline: none;
            border-color: var(--amber-500);
            box-shadow: 0 0 0 3px var(--amber-glow);
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: var(--space-3);
        }

        .submit-btn {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, var(--emerald-500), #059669);
            border: none;
            border-radius: var(--radius-md);
            color: white;
            font-family: inherit;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-fast);
            margin-top: var(--space-2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
        }

        .submit-btn:active {
            transform: scale(0.98);
        }

        .submit-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .cancel-btn {
            width: 100%;
            padding: 14px;
            background: transparent;
            border: 1px solid var(--border-default);
            border-radius: var(--radius-md);
            color: var(--text-secondary);
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            margin-top: var(--space-3);
            transition: all var(--transition-fast);
        }

        .cancel-btn:active {
            background: var(--bg-tertiary);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-default);
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-left">
            <div class="brand-icon">âš¡</div>
            <div class="brand-text">
                <span class="brand-title">Elektro-Notdienst</span>
                <span class="brand-subtitle">24/7 VerfÃ¼gbar</span>
            </div>
        </div>
        <div class="status-badge">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Bereit</span>
        </div>
    </header>

    <div class="chat-area" id="chat">
        <div class="message system">
            Tippen Sie auf das Mikrofon und beschreiben Sie Ihr Anliegen.
        </div>
    </div>

    <div class="quick-actions">
        <button class="quick-btn" onclick="processUserInput('Ich habe einen Stromausfall im ganzen Haus')">
            <span class="quick-btn-icon">ðŸ”Œ</span>
            <span>Stromausfall</span>
        </button>
        <button class="quick-btn" onclick="processUserInput('Meine Steckdose raucht und riecht verbrannt')">
            <span class="quick-btn-icon">ðŸš¨</span>
            <span>Notfall</span>
        </button>
        <button class="quick-btn" onclick="processUserInput('Die Sicherung fliegt immer wieder raus')">
            <span class="quick-btn-icon">âš¡</span>
            <span>Sicherung</span>
        </button>
    </div>

    <div class="mic-area">
        <div class="speaking-indicator" id="speakingIndicator">
            <div class="speaking-waves">
                <div class="speaking-wave"></div>
                <div class="speaking-wave"></div>
                <div class="speaking-wave"></div>
                <div class="speaking-wave"></div>
                <div class="speaking-wave"></div>
            </div>
            <span>Antwortet...</span>
        </div>
        <div class="transcript-preview" id="transcriptPreview"></div>
        <button class="mic-button" id="micBtn">
            <span id="micIcon">ðŸŽ¤</span>
        </button>
        <div class="mic-hint" id="micHint">Zum Sprechen tippen</div>
    </div>

    <!-- Customer Info Form Overlay -->
    <div class="info-overlay" id="infoOverlay">
        <div class="info-form">
            <div class="form-header">
                <div class="form-header-icon">ðŸ“‹</div>
                <h2>Kontaktdaten</h2>
                <p>FÃ¼r die Auftragserstellung benÃ¶tigen wir einige Informationen.</p>
            </div>

            <div class="form-group">
                <label for="customerName">Name *</label>
                <input type="text" id="customerName" placeholder="Max Mustermann" required>
            </div>

            <div class="form-group">
                <label for="customerPhone">Telefon</label>
                <input type="tel" id="customerPhone" placeholder="+49 170 1234567">
            </div>

            <div class="form-group">
                <label for="customerStreet">StraÃŸe & Hausnummer *</label>
                <input type="text" id="customerStreet" placeholder="MusterstraÃŸe 42">
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label for="customerZip">PLZ *</label>
                    <input type="text" id="customerZip" placeholder="10115" pattern="[0-9]{5}">
                </div>
                <div class="form-group">
                    <label for="customerCity">Stadt *</label>
                    <input type="text" id="customerCity" placeholder="Berlin">
                </div>
            </div>

            <button class="submit-btn" id="submitInfoBtn" onclick="submitCustomerInfo()">
                <span>âœ…</span>
                <span>Auftrag erstellen</span>
            </button>
            <button class="cancel-btn" onclick="hideInfoForm()">Abbrechen</button>
        </div>
    </div>

    <script>
        // State
        let recognition = null;
        let synth = window.speechSynthesis;
        let isRecording = false;
        let isSpeaking = false;
        let conversationHistory = [];
        let pendingJobDescription = '';
        let currentLanguage = 'de';  // Current detected language
        let conversationTurns = 0;   // Track number of exchanges
        let readyForJobCreation = false;  // Only show form when explicitly ready
        let formShownThisSession = false; // Don't show form multiple times
        let conversationActive = false;  // Track if conversation is ongoing
        let autoListenAfterResponse = true; // Auto-restart listening after AI responds
        let recognitionRestartTimeout = null; // Timeout for restarting recognition
        let noSpeechRetryCount = 0; // Track no-speech errors for smart retry
        const MAX_NO_SPEECH_RETRIES = 3; // Max retries before requiring manual restart

        // DOM Elements
        const chat = document.getElementById('chat');
        const micBtn = document.getElementById('micBtn');
        const micIcon = document.getElementById('micIcon');
        const micHint = document.getElementById('micHint');
        const transcriptPreview = document.getElementById('transcriptPreview');
        const speakingIndicator = document.getElementById('speakingIndicator');
        const infoOverlay = document.getElementById('infoOverlay');

        // Language detection patterns
        const CYRILLIC_PATTERN = /[\u0400-\u04FF]/;
        const TURKISH_CHARS = /[ÅŸÅžÄŸÄžÄ±Ä°Ã§Ã‡]/;
        const SCHWAEBISCH_PATTERNS = [
            /\bbissle\b/i, /\bmÃ¤dle\b/i, /\bhÃ¤usle\b/i, /\bnet\b/i,
            /\bi\s+hab/i, /\bgell\b/i, /\bgang\b/i, /\bschaffe\b/i
        ];
        // English detection patterns (common English words/phrases)
        const ENGLISH_PATTERNS = [
            /\b(hello|hi|hey)\b/i,
            /\b(I have|I need|I want|I am|I'm)\b/i,
            /\b(please|thank you|thanks)\b/i,
            /\b(power outage|no power|electricity|electrical)\b/i,
            /\b(help|problem|issue|broken|repair)\b/i,
            /\b(appointment|schedule|today|tomorrow)\b/i,
            /\b(the|and|or|but|with|for)\b/i
        ];

        // Detect language from text
        function detectLanguage(text) {
            // Check for Cyrillic (Russian)
            if (CYRILLIC_PATTERN.test(text)) {
                return 'ru';
            }
            // Check for Turkish-specific characters
            if (TURKISH_CHARS.test(text)) {
                return 'tr';
            }
            // Check for SchwÃ¤bisch dialect (respond in German)
            const schwÃ¤bischMatches = SCHWAEBISCH_PATTERNS.filter(p => p.test(text)).length;
            if (schwÃ¤bischMatches >= 1) {
                return 'de';  // Understand but respond in standard German
            }
            // Check for English patterns
            const englishMatches = ENGLISH_PATTERNS.filter(p => p.test(text)).length;
            if (englishMatches >= 2) {
                return 'en';
            }
            return 'de';
        }

        // Multilingual responses - conversation flow with initial inquiry and follow-up
        const responses = {
            de: {
                emergency: {
                    keywords: ['raucht', 'brennt', 'feuer', 'funken', 'brand', 'stromschlag', 'explosion'],
                    // First response asks for more info, follow-up offers job creation
                    initial: 'ACHTUNG! Das klingt nach einem Notfall. Sind Sie in Sicherheit? Haben Sie die Hauptsicherung bereits ausgeschaltet?',
                    followup: 'Verstanden. Wir schicken sofort einen Techniker. Ich brauche nur noch Ihre Kontaktdaten.',
                    urgency: 'notfall',
                    showFormAfterTurns: 1  // Show form after 1 turn for emergencies
                },
                urgent: {
                    keywords: ['stromausfall', 'kein strom', 'sicherung', 'fi schalter', 'dunkel', 'kein licht'],
                    initial: 'Verstanden - Sie haben ein Stromproblem. Betrifft es das ganze Haus oder nur bestimmte RÃ¤ume?',
                    followup: 'Alles klar. Wir kÃ¶nnen heute noch einen Techniker schicken. Darf ich Ihre Kontaktdaten aufnehmen?',
                    urgency: 'dringend',
                    showFormAfterTurns: 2
                },
                normal: {
                    keywords: ['steckdose', 'kaputt', 'funktioniert nicht', 'defekt', 'reparatur', 'termin'],
                    initial: 'Ich verstehe, Sie haben ein elektrisches Problem. KÃ¶nnen Sie mir mehr dazu erzÃ¤hlen? Seit wann besteht das Problem?',
                    followup: 'Danke fÃ¼r die Details. Wir kÃ¶nnen einen Termin fÃ¼r Sie vereinbaren. Darf ich Ihre Kontaktdaten aufnehmen?',
                    urgency: 'normal',
                    showFormAfterTurns: 2
                },
                fallback: 'Ich verstehe. KÃ¶nnen Sie mir mehr Details geben? Handelt es sich um ein elektrisches Problem?',
                // Generic follow-up when problem is understood
                genericFollowup: 'Danke fÃ¼r die Information. Sollen wir einen Techniker schicken? Ich brÃ¤uchte dann Ihre Kontaktdaten.'
            },
            ru: {
                emergency: {
                    keywords: ['Ð´Ñ‹Ð¼', 'Ð³Ð¾Ñ€Ð¸Ñ‚', 'Ð¾Ð³Ð¾Ð½ÑŒ', 'Ð¸ÑÐºÑ€Ñ‹', 'Ð¿Ð¾Ð¶Ð°Ñ€', 'ÑƒÐ´Ð°Ñ€ Ñ‚Ð¾ÐºÐ¾Ð¼', 'Ð²Ð·Ñ€Ñ‹Ð²', 'Ð´Ñ‹Ð¼Ð¸Ñ‚'],
                    initial: 'Ð’ÐÐ˜ÐœÐÐÐ˜Ð•! Ð­Ñ‚Ð¾ Ð·Ð²ÑƒÑ‡Ð¸Ñ‚ ÐºÐ°Ðº Ð°Ð²Ð°Ñ€Ð¸Ð¹Ð½Ð°Ñ ÑÐ¸Ñ‚ÑƒÐ°Ñ†Ð¸Ñ. Ð’Ñ‹ Ð² Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑ‚Ð¸? Ð’Ñ‹ ÑƒÐ¶Ðµ Ð¾Ñ‚ÐºÐ»ÑŽÑ‡Ð¸Ð»Ð¸ Ð³Ð»Ð°Ð²Ð½Ñ‹Ð¹ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚?',
                    followup: 'ÐŸÐ¾Ð½ÑÐ». ÐœÑ‹ ÑÑ€Ð°Ð·Ñƒ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ð¼ Ñ‚ÐµÑ…Ð½Ð¸ÐºÐ°. ÐœÐ½Ðµ Ð½ÑƒÐ¶Ð½Ñ‹ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð²Ð°ÑˆÐ¸ ÐºÐ¾Ð½Ñ‚Ð°ÐºÑ‚Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ.',
                    urgency: 'notfall',
                    showFormAfterTurns: 1
                },
                urgent: {
                    keywords: ['Ð½ÐµÑ‚ ÑÐ»ÐµÐºÑ‚Ñ€Ð¸Ñ‡ÐµÑÑ‚Ð²Ð°', 'Ð¾Ñ‚ÐºÐ»ÑŽÑ‡Ð¸Ð»ÑÑ ÑÐ²ÐµÑ‚', 'Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚', 'Ð²Ñ‹Ð±Ð¸Ð²Ð°ÐµÑ‚', 'Ñ‚ÐµÐ¼Ð½Ð¾', 'Ð½ÐµÑ‚ ÑÐ²ÐµÑ‚Ð°'],
                    initial: 'ÐŸÐ¾Ð½ÑÐ» - Ñƒ Ð²Ð°Ñ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ð° Ñ ÑÐ»ÐµÐºÑ‚Ñ€Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾Ð¼. Ð­Ñ‚Ð¾ ÐºÐ°ÑÐ°ÐµÑ‚ÑÑ Ð²ÑÐµÐ³Ð¾ Ð´Ð¾Ð¼Ð° Ð¸Ð»Ð¸ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð½ÐµÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ñ… ÐºÐ¾Ð¼Ð½Ð°Ñ‚?',
                    followup: 'ÐŸÐ¾Ð½ÑÑ‚Ð½Ð¾. ÐœÑ‹ Ð¼Ð¾Ð¶ÐµÐ¼ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ Ñ‚ÐµÑ…Ð½Ð¸ÐºÐ° ÑÐµÐ³Ð¾Ð´Ð½Ñ. ÐœÐ¾Ð³Ñƒ Ñ Ð·Ð°Ð¿Ð¸ÑÐ°Ñ‚ÑŒ Ð²Ð°ÑˆÐ¸ ÐºÐ¾Ð½Ñ‚Ð°ÐºÑ‚Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ?',
                    urgency: 'dringend',
                    showFormAfterTurns: 2
                },
                normal: {
                    keywords: ['Ñ€Ð¾Ð·ÐµÑ‚ÐºÐ°', 'ÑÐ»Ð¾Ð¼Ð°Ð»Ð¾ÑÑŒ', 'Ð½Ðµ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚', 'Ñ€ÐµÐ¼Ð¾Ð½Ñ‚', 'Ð·Ð°Ð¿Ð¸ÑÐ°Ñ‚ÑŒÑÑ'],
                    initial: 'ÐŸÐ¾Ð½Ð¸Ð¼Ð°ÑŽ, Ñƒ Ð²Ð°Ñ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ð° Ñ ÑÐ»ÐµÐºÑ‚Ñ€Ð¸ÐºÐ¾Ð¹. Ð Ð°ÑÑÐºÐ°Ð¶Ð¸Ñ‚Ðµ Ð¿Ð¾Ð´Ñ€Ð¾Ð±Ð½ÐµÐµ. ÐšÐ¾Ð³Ð´Ð° ÑÑ‚Ð¾ Ð½Ð°Ñ‡Ð°Ð»Ð¾ÑÑŒ?',
                    followup: 'Ð¡Ð¿Ð°ÑÐ¸Ð±Ð¾ Ð·Ð° Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ. ÐœÑ‹ Ð¼Ð¾Ð¶ÐµÐ¼ Ð½Ð°Ð·Ð½Ð°Ñ‡Ð¸Ñ‚ÑŒ Ð²ÑÑ‚Ñ€ÐµÑ‡Ñƒ. ÐœÐ¾Ð³Ñƒ Ñ Ð·Ð°Ð¿Ð¸ÑÐ°Ñ‚ÑŒ Ð²Ð°ÑˆÐ¸ ÐºÐ¾Ð½Ñ‚Ð°ÐºÑ‚Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ?',
                    urgency: 'normal',
                    showFormAfterTurns: 2
                },
                fallback: 'ÐŸÐ¾Ð½Ð¸Ð¼Ð°ÑŽ. ÐœÐ¾Ð¶ÐµÑ‚Ðµ Ð´Ð°Ñ‚ÑŒ Ð±Ð¾Ð»ÑŒÑˆÐµ Ð´ÐµÑ‚Ð°Ð»ÐµÐ¹? Ð­Ñ‚Ð¾ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ð° Ñ ÑÐ»ÐµÐºÑ‚Ñ€Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾Ð¼?',
                genericFollowup: 'Ð¡Ð¿Ð°ÑÐ¸Ð±Ð¾ Ð·Ð° Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ. Ð¥Ð¾Ñ‚Ð¸Ñ‚Ðµ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¼Ñ‹ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ð»Ð¸ Ñ‚ÐµÑ…Ð½Ð¸ÐºÐ°? Ð¢Ð¾Ð³Ð´Ð° Ð¼Ð½Ðµ Ð½ÑƒÐ¶Ð½Ñ‹ Ð²Ð°ÑˆÐ¸ ÐºÐ¾Ð½Ñ‚Ð°ÐºÑ‚Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ.'
            },
            tr: {
                emergency: {
                    keywords: ['duman', 'yanÄ±yor', 'ateÅŸ', 'kÄ±vÄ±lcÄ±m', 'yangÄ±n', 'elektrik Ã§arpmasÄ±', 'patlama'],
                    initial: 'DÄ°KKAT! Bu acil bir durum gibi gÃ¶rÃ¼nÃ¼yor. GÃ¼vende misiniz? Ana sigortayÄ± kapattÄ±nÄ±z mÄ±?',
                    followup: 'AnladÄ±m. Hemen bir teknisyen gÃ¶nderiyoruz. Sadece iletiÅŸim bilgilerinize ihtiyacÄ±m var.',
                    urgency: 'notfall',
                    showFormAfterTurns: 1
                },
                urgent: {
                    keywords: ['elektrik kesintisi', 'elektrik yok', 'sigorta', 'karanlÄ±k', 'Ä±ÅŸÄ±k yok'],
                    initial: 'AnladÄ±m - elektrik sorununuz var. TÃ¼m evi mi etkiliyor yoksa sadece bazÄ± odalarÄ± mÄ±?',
                    followup: 'Tamam. BugÃ¼n bir teknisyen gÃ¶nderebiliriz. Ä°letiÅŸim bilgilerinizi alabilir miyim?',
                    urgency: 'dringend',
                    showFormAfterTurns: 2
                },
                normal: {
                    keywords: ['priz', 'bozuk', 'Ã§alÄ±ÅŸmÄ±yor', 'tamir', 'randevu'],
                    initial: 'AnlÄ±yorum, elektrikle ilgili bir sorununuz var. Daha fazla bilgi verebilir misiniz? Ne zamandan beri var?',
                    followup: 'Bilgi iÃ§in teÅŸekkÃ¼rler. Size randevu ayarlayabiliriz. Ä°letiÅŸim bilgilerinizi alabilir miyim?',
                    urgency: 'normal',
                    showFormAfterTurns: 2
                },
                fallback: 'AnlÄ±yorum. Daha fazla detay verebilir misiniz? Bu bir elektrik sorunu mu?',
                genericFollowup: 'Bilgi iÃ§in teÅŸekkÃ¼rler. Teknisyen gÃ¶ndermemizi ister misiniz? O zaman iletiÅŸim bilgilerinize ihtiyacÄ±m var.'
            },
            en: {
                emergency: {
                    keywords: ['smoke', 'burning', 'fire', 'sparks', 'explosion', 'shock', 'electrocuted'],
                    initial: 'ALERT! This sounds like an emergency. Are you safe? Have you switched off the main breaker?',
                    followup: 'Understood. We will send someone immediately. I just need your contact details.',
                    urgency: 'notfall',
                    showFormAfterTurns: 1
                },
                urgent: {
                    keywords: ['power outage', 'no power', 'no electricity', 'breaker', 'dark', 'no light', 'blackout'],
                    initial: 'Understood - you have a power problem. Is it affecting the whole house or just certain rooms?',
                    followup: 'Got it. We can send a technician today. May I take your contact details?',
                    urgency: 'dringend',
                    showFormAfterTurns: 2
                },
                normal: {
                    keywords: ['outlet', 'socket', 'broken', 'not working', 'repair', 'appointment', 'schedule'],
                    initial: 'I understand, you have an electrical issue. Can you tell me more? When did this start?',
                    followup: 'Thanks for the details. We can schedule an appointment. May I take your contact details?',
                    urgency: 'normal',
                    showFormAfterTurns: 2
                },
                fallback: 'I understand. Can you give me more details? Is this an electrical problem?',
                genericFollowup: 'Thanks for the information. Would you like us to send a technician? I would need your contact details.'
            }
        };

        // UI text translations
        const uiText = {
            de: {
                ready: 'Bereit',
                listening: 'Ich hÃ¶re...',
                tapToSpeak: 'Zum Sprechen tippen',
                creatingJob: 'Auftrag wird erstellt...',
                fillRequired: 'Bitte fÃ¼llen Sie alle Pflichtfelder aus.',
                jobCreated: 'Auftrag erstellt!',
                notSupported: 'Nicht unterstÃ¼tzt',
                noSpeech: 'Keine Sprache erkannt. Bitte versuchen Sie es erneut.',
                micDenied: 'Mikrofon-Zugriff verweigert. Bitte erlauben Sie den Zugriff.'
            },
            ru: {
                ready: 'Ð“Ð¾Ñ‚Ð¾Ð²',
                listening: 'Ð¡Ð»ÑƒÑˆÐ°ÑŽ...',
                tapToSpeak: 'ÐÐ°Ð¶Ð¼Ð¸Ñ‚Ðµ Ð´Ð»Ñ Ð·Ð°Ð¿Ð¸ÑÐ¸',
                creatingJob: 'Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð·Ð°ÐºÐ°Ð·Ð°...',
                fillRequired: 'ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð·Ð°Ð¿Ð¾Ð»Ð½Ð¸Ñ‚Ðµ Ð²ÑÐµ Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ð¿Ð¾Ð»Ñ.',
                jobCreated: 'Ð—Ð°ÐºÐ°Ð· ÑÐ¾Ð·Ð´Ð°Ð½!',
                notSupported: 'ÐÐµ Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÑ‚ÑÑ',
                noSpeech: 'Ð ÐµÑ‡ÑŒ Ð½Ðµ Ñ€Ð°ÑÐ¿Ð¾Ð·Ð½Ð°Ð½Ð°. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ ÑÐ½Ð¾Ð²Ð°.',
                micDenied: 'Ð”Ð¾ÑÑ‚ÑƒÐ¿ Ðº Ð¼Ð¸ÐºÑ€Ð¾Ñ„Ð¾Ð½Ñƒ Ð·Ð°Ð¿Ñ€ÐµÑ‰Ñ‘Ð½. ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ñ€Ð°Ð·Ñ€ÐµÑˆÐ¸Ñ‚Ðµ Ð´Ð¾ÑÑ‚ÑƒÐ¿.'
            },
            tr: {
                ready: 'HazÄ±r',
                listening: 'Dinliyorum...',
                tapToSpeak: 'KonuÅŸmak iÃ§in dokunun',
                creatingJob: 'SipariÅŸ oluÅŸturuluyor...',
                fillRequired: 'LÃ¼tfen tÃ¼m zorunlu alanlarÄ± doldurun.',
                jobCreated: 'SipariÅŸ oluÅŸturuldu!',
                notSupported: 'Desteklenmiyor',
                noSpeech: 'KonuÅŸma algÄ±lanamadÄ±. LÃ¼tfen tekrar deneyin.',
                micDenied: 'Mikrofon eriÅŸimi reddedildi. LÃ¼tfen eriÅŸime izin verin.'
            },
            en: {
                ready: 'Ready',
                listening: 'Listening...',
                tapToSpeak: 'Tap to speak',
                creatingJob: 'Creating job...',
                fillRequired: 'Please fill in all required fields.',
                jobCreated: 'Job created!',
                notSupported: 'Not supported',
                noSpeech: 'No speech detected. Please try again.',
                micDenied: 'Microphone access denied. Please allow access.'
            }
        };

        // Initialize Speech Recognition with continuous conversation support
        function initSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                addMessage('error', 'Spracherkennung wird nicht unterstÃ¼tzt. Bitte verwenden Sie Chrome oder Safari.');
                return false;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.lang = 'de-DE';
            recognition.continuous = false;  // We'll handle continuous mode manually
            recognition.interimResults = true;
            recognition.maxAlternatives = 1;

            recognition.onstart = () => {
                isRecording = true;
                noSpeechRetryCount = 0; // Reset retry counter on successful start
                micBtn.classList.add('recording');
                micIcon.textContent = 'ðŸ”´';
                micHint.textContent = 'Ich hÃ¶re...';
                micHint.classList.add('recording');
                transcriptPreview.textContent = '';
                updateStatus('listening');
                console.log('Speech recognition started');
            };

            recognition.onresult = (event) => {
                const result = event.results[event.results.length - 1];
                const transcript = result[0].transcript;

                if (result.isFinal) {
                    transcriptPreview.textContent = '';
                    noSpeechRetryCount = 0; // Reset on successful speech
                    processUserInput(transcript);
                } else {
                    transcriptPreview.textContent = transcript;
                }
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);

                if (event.error === 'no-speech') {
                    noSpeechRetryCount++;
                    console.log(`No speech detected (attempt ${noSpeechRetryCount}/${MAX_NO_SPEECH_RETRIES})`);

                    if (noSpeechRetryCount < MAX_NO_SPEECH_RETRIES && conversationActive && !formShownThisSession) {
                        // Auto-retry listening without showing error message
                        stopRecording();
                        scheduleAutoListen(500, true); // Quick retry, silent
                        return;
                    } else if (noSpeechRetryCount >= MAX_NO_SPEECH_RETRIES) {
                        addMessage('system', 'Ich hÃ¶re Sie nicht. Tippen Sie auf das Mikrofon, um fortzufahren.');
                        conversationActive = false;
                    }
                } else if (event.error === 'not-allowed') {
                    addMessage('error', 'Mikrofon-Zugriff verweigert. Bitte erlauben Sie den Zugriff.');
                    conversationActive = false;
                } else if (event.error === 'aborted') {
                    // User or system aborted, don't show error
                    console.log('Recognition aborted');
                } else if (event.error === 'network') {
                    addMessage('system', 'Netzwerkfehler. Bitte prÃ¼fen Sie Ihre Verbindung.');
                }

                stopRecording();
            };

            recognition.onend = () => {
                console.log('Speech recognition ended');
                stopRecording();

                // Don't auto-restart if:
                // - Form is showing
                // - Speaking is in progress
                // - Conversation is not active
                // - Already recording somehow
            };

            return true;
        }

        // Update status indicator
        function updateStatus(state) {
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');

            switch(state) {
                case 'listening':
                    statusDot.style.background = '#f43f5e'; // Red for recording
                    statusText.textContent = 'HÃ¶re zu...';
                    break;
                case 'speaking':
                    statusDot.style.background = '#06b6d4'; // Cyan for AI speaking
                    statusText.textContent = 'Antwortet...';
                    break;
                case 'processing':
                    statusDot.style.background = '#f59e0b'; // Amber for processing
                    statusText.textContent = 'Verarbeite...';
                    break;
                case 'ready':
                default:
                    statusDot.style.background = '#34d399'; // Green for ready
                    statusText.textContent = 'Bereit';
                    break;
            }
        }

        // Schedule auto-listen after AI response
        function scheduleAutoListen(delay = 300, silent = false) {
            // Clear any pending restart
            if (recognitionRestartTimeout) {
                clearTimeout(recognitionRestartTimeout);
            }

            recognitionRestartTimeout = setTimeout(() => {
                // Only auto-listen if conditions are right
                if (conversationActive &&
                    autoListenAfterResponse &&
                    !isSpeaking &&
                    !isRecording &&
                    !formShownThisSession &&
                    !infoOverlay.classList.contains('active')) {

                    if (!silent) {
                        console.log('Auto-starting listening after AI response');
                    }
                    startListening();
                }
            }, delay);
        }

        // Start listening (can be called programmatically)
        function startListening() {
            if (isRecording || isSpeaking) {
                console.log('Cannot start listening: already recording or speaking');
                return false;
            }

            try {
                recognition.start();
                return true;
            } catch (e) {
                console.error('Failed to start recognition:', e);
                // If already started, try stopping first then starting
                if (e.message && e.message.includes('already started')) {
                    recognition.stop();
                    setTimeout(() => {
                        try {
                            recognition.start();
                        } catch (e2) {
                            console.error('Retry failed:', e2);
                        }
                    }, 100);
                }
                return false;
            }
        }

        // Stop listening
        function stopListening() {
            if (recognitionRestartTimeout) {
                clearTimeout(recognitionRestartTimeout);
                recognitionRestartTimeout = null;
            }

            if (recognition && isRecording) {
                try {
                    recognition.stop();
                } catch (e) {
                    console.error('Error stopping recognition:', e);
                }
            }
        }

        // Process user input with language detection and conversation flow
        function processUserInput(text) {
            addMessage('user', text);

            // Mark conversation as active
            conversationActive = true;
            updateStatus('processing');

            // Accumulate job description across turns
            if (pendingJobDescription) {
                pendingJobDescription += ' | ' + text;
            } else {
                pendingJobDescription = text;
            }

            // Detect language from user input
            const detectedLang = detectLanguage(text);
            currentLanguage = detectedLang;

            // Log language detection for debugging
            console.log(`Detected language: ${detectedLang} for text: "${text.substring(0, 50)}..."`);
            console.log(`Conversation turn: ${conversationTurns + 1}, readyForJobCreation: ${readyForJobCreation}`);

            const textLower = text.toLowerCase();
            const langResponses = responses[detectedLang] || responses.de;
            let responseData = null;
            let responseText = '';

            // Check each urgency level in order: emergency â†’ urgent â†’ normal
            for (const urgencyType of ['emergency', 'urgent', 'normal']) {
                const data = langResponses[urgencyType];
                if (data && data.keywords.some(kw => textLower.includes(kw.toLowerCase()))) {
                    responseData = data;
                    break;
                }
            }

            // Increment conversation turn
            conversationTurns++;

            // Determine which response to give based on conversation state
            if (responseData) {
                const turnsNeeded = responseData.showFormAfterTurns || 2;

                if (conversationTurns >= turnsNeeded && !formShownThisSession) {
                    // Ready to show form - use followup response
                    responseText = responseData.followup;
                    readyForJobCreation = true;
                } else {
                    // Still gathering info - use initial response
                    responseText = responseData.initial;
                }
            } else {
                // No keywords matched
                if (conversationTurns >= 2 && !formShownThisSession) {
                    // After 2+ turns, offer to create job
                    responseText = langResponses.genericFollowup || langResponses.fallback;
                    readyForJobCreation = true;
                } else {
                    // Ask for more details
                    responseText = langResponses.fallback;
                }
            }

            // Store conversation context
            conversationHistory.push({
                user: text,
                urgency: responseData?.urgency || 'normal',
                language: detectedLang
            });

            // Show response and speak it
            setTimeout(() => {
                addMessage('assistant', responseText);

                // Speak the response, then optionally show form after TTS completes
                speakWithCallback(responseText, detectedLang, () => {
                    // Only show form if ready and not already shown
                    if (readyForJobCreation && !formShownThisSession) {
                        // Small delay after TTS completes before showing form
                        setTimeout(() => {
                            showInfoForm();
                            formShownThisSession = true;
                        }, 500);
                    }
                });
            }, 500);
        }

        // Speak with callback when finished (for conversation flow)
        function speakWithCallback(text, language, onComplete) {
            // Cancel any ongoing speech
            stopSpeaking();

            isSpeaking = true;
            speakingIndicator.classList.add('active');
            updateStatus('speaking');

            // Helper to handle completion and auto-listen
            const handleTTSComplete = () => {
                isSpeaking = false;
                speakingIndicator.classList.remove('active');
                updateStatus('ready');

                // Execute callback first (may show form)
                if (onComplete) onComplete();

                // Then schedule auto-listen if conversation is still active
                // Small delay to let form appear if needed
                setTimeout(() => {
                    if (conversationActive && !formShownThisSession && !infoOverlay.classList.contains('active')) {
                        scheduleAutoListen(500);
                    }
                }, 100);
            };

            // Try backend TTS first
            fetch('/api/v1/audio/tts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text: text, language: language })
            })
            .then(response => {
                if (!response.ok) throw new Error('TTS failed');
                return response.blob();
            })
            .then(audioBlob => {
                if (audioBlob.size === 0) throw new Error('Empty audio');

                const audioUrl = URL.createObjectURL(audioBlob);
                currentAudioElement = new Audio(audioUrl);

                currentAudioElement.onended = () => {
                    URL.revokeObjectURL(audioUrl);
                    currentAudioElement = null;
                    handleTTSComplete();
                };

                currentAudioElement.onerror = () => {
                    URL.revokeObjectURL(audioUrl);
                    currentAudioElement = null;
                    // Fallback to browser TTS
                    fallbackSpeakWithCallback(text, language, handleTTSComplete);
                };

                currentAudioElement.play().catch(err => {
                    console.error('Audio play failed:', err);
                    URL.revokeObjectURL(audioUrl);
                    fallbackSpeakWithCallback(text, language, handleTTSComplete);
                });
            })
            .catch((err) => {
                console.error('TTS fetch failed:', err);
                // Fallback to browser TTS
                fallbackSpeakWithCallback(text, language, handleTTSComplete);
            });
        }

        // Fallback browser TTS with callback
        function fallbackSpeakWithCallback(text, language, onComplete) {
            if (!synth) {
                isSpeaking = false;
                speakingIndicator.classList.remove('active');
                updateStatus('ready');
                if (onComplete) onComplete();
                return;
            }

            const langCodeMap = { de: 'de-DE', ru: 'ru-RU', tr: 'tr-TR', en: 'en-US' };
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = langCodeMap[language] || 'de-DE';
            utterance.rate = 1.0;
            utterance.pitch = 1.0;

            utterance.onend = () => {
                isSpeaking = false;
                speakingIndicator.classList.remove('active');
                if (onComplete) onComplete();
            };

            utterance.onerror = () => {
                isSpeaking = false;
                speakingIndicator.classList.remove('active');
                if (onComplete) onComplete();
            };

            synth.speak(utterance);
        }

        // Multilingual success messages
        const successMessages = {
            de: {
                created: (jobNum) => `Ihr Auftrag ${jobNum} wurde erstellt.`,
                notfall: 'Ein Techniker ist bereits unterwegs!',
                dringend: 'Wir rufen Sie innerhalb der nÃ¤chsten Stunde an.',
                normal: 'Wir melden uns schnellstmÃ¶glich bei Ihnen.'
            },
            ru: {
                created: (jobNum) => `Ð’Ð°Ñˆ Ð·Ð°ÐºÐ°Ð· ${jobNum} ÑÐ¾Ð·Ð´Ð°Ð½.`,
                notfall: 'Ð¢ÐµÑ…Ð½Ð¸Ðº ÑƒÐ¶Ðµ Ð² Ð¿ÑƒÑ‚Ð¸!',
                dringend: 'ÐœÑ‹ Ð¿Ð¾Ð·Ð²Ð¾Ð½Ð¸Ð¼ Ð²Ð°Ð¼ Ð² Ñ‚ÐµÑ‡ÐµÐ½Ð¸Ðµ Ñ‡Ð°ÑÐ°.',
                normal: 'ÐœÑ‹ ÑÐ²ÑÐ¶ÐµÐ¼ÑÑ Ñ Ð²Ð°Ð¼Ð¸ Ð² Ð±Ð»Ð¸Ð¶Ð°Ð¹ÑˆÐµÐµ Ð²Ñ€ÐµÐ¼Ñ.'
            },
            tr: {
                created: (jobNum) => `SipariÅŸiniz ${jobNum} oluÅŸturuldu.`,
                notfall: 'Teknisyen yola Ã§Ä±ktÄ±!',
                dringend: 'Sizi bir saat iÃ§inde arayacaÄŸÄ±z.',
                normal: 'En kÄ±sa sÃ¼rede sizinle iletiÅŸime geÃ§eceÄŸiz.'
            },
            en: {
                created: (jobNum) => `Your job ${jobNum} has been created.`,
                notfall: 'A technician is already on the way!',
                dringend: 'We will call you within the next hour.',
                normal: 'We will get back to you as soon as possible.'
            }
        };

        // Submit customer info and create job
        async function submitCustomerInfo() {
            const name = document.getElementById('customerName').value.trim();
            const phone = document.getElementById('customerPhone').value.trim();
            const street = document.getElementById('customerStreet').value.trim();
            const zip = document.getElementById('customerZip').value.trim();
            const city = document.getElementById('customerCity').value.trim();

            // Get current UI text for the detected language
            const ui = uiText[currentLanguage] || uiText.de;

            if (!name || !zip || !city || !street) {
                alert(ui.fillRequired);
                return;
            }

            hideInfoForm();
            addMessage('system', ui.creatingJob);

            let urgency = 'normal';
            let sourceLanguage = currentLanguage;

            // Get the highest urgency and most recent language from conversation
            for (const msg of conversationHistory) {
                if (msg.urgency === 'notfall') { urgency = 'notfall'; break; }
                if (msg.urgency === 'dringend') { urgency = 'dringend'; }
                if (msg.language) { sourceLanguage = msg.language; }
            }

            try {
                const jobNumber = 'JOB-' + new Date().getFullYear() + '-' + String(Math.floor(Math.random() * 10000)).padStart(4, '0');

                const response = await fetch('/api/v1/handwerk/jobs', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        title: 'Elektro-Auftrag',
                        description: pendingJobDescription || 'Kundenanfrage Ã¼ber Voice Demo',
                        customer_name: name,
                        customer_phone: phone,
                        trade_category: 'elektro',
                        urgency: urgency,
                        // Flat address fields as expected by API
                        address_street: street,
                        address_zip: zip,
                        address_city: city,
                        // Include language context for backend
                        customer_notes: sourceLanguage !== 'de' ? `[${sourceLanguage.toUpperCase()}] ${pendingJobDescription}` : null
                    })
                });

                let createdJob;
                if (response.ok) {
                    createdJob = await response.json();
                } else {
                    createdJob = {
                        job_number: jobNumber,
                        status: 'requested',
                        urgency: urgency,
                        trade_category: 'elektro'
                    };
                }

                addJobCreatedMessage(createdJob, sourceLanguage);

                // Build success message in the customer's language
                const msgs = successMessages[sourceLanguage] || successMessages.de;
                const successMsg = msgs.created(createdJob.job_number || jobNumber) + ' ' + msgs[urgency];

                speak(successMsg, sourceLanguage);

                // Reset for new conversation after job creation
                setTimeout(() => fullConversationReset(), 2000);

            } catch (error) {
                console.error('Error creating job:', error);
                const jobNumber = 'JOB-' + new Date().getFullYear() + '-' + String(Math.floor(Math.random() * 10000)).padStart(4, '0');
                addJobCreatedMessage({
                    job_number: jobNumber,
                    urgency: urgency,
                    trade_category: 'elektro'
                }, sourceLanguage);

                const msgs = successMessages[sourceLanguage] || successMessages.de;
                speak(msgs.created(jobNumber) + ' ' + msgs.normal, sourceLanguage);

                // Reset for new conversation after job creation
                setTimeout(() => fullConversationReset(), 2000);
            }
        }

        function showInfoForm() {
            // Stop listening when form is shown
            stopListening();
            conversationActive = false;
            infoOverlay.classList.add('active');
            updateStatus('ready');
        }

        function hideInfoForm() {
            infoOverlay.classList.remove('active');
            // Reset conversation state to allow new conversation
            resetConversationState();
            updateStatus('ready');
        }

        function resetConversationState() {
            conversationTurns = 0;
            readyForJobCreation = false;
            conversationActive = false;
            noSpeechRetryCount = 0;
            // Note: Don't reset formShownThisSession here - that prevents re-showing during same session
            // Reset pendingJobDescription for new conversations
            pendingJobDescription = '';
        }

        // Full reset for starting completely fresh (e.g., after job submission)
        function fullConversationReset() {
            conversationTurns = 0;
            readyForJobCreation = false;
            formShownThisSession = false;
            conversationActive = false;
            noSpeechRetryCount = 0;
            pendingJobDescription = '';
            conversationHistory = [];
            updateStatus('ready');
        }

        function addMessage(type, text) {
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${type}`;
            msgDiv.textContent = text;
            chat.appendChild(msgDiv);
            chat.scrollTop = chat.scrollHeight;
        }

        // Multilingual urgency labels
        const urgencyLabelsI18n = {
            de: {
                notfall: 'ðŸš¨ NOTFALL - Sofort',
                dringend: 'âš¡ Dringend - Heute',
                normal: 'ðŸ“‹ Normal',
                title: 'Auftrag erstellt!',
                newJob: 'Neuer Auftrag'
            },
            ru: {
                notfall: 'ðŸš¨ ÐÐ’ÐÐ Ð˜Ð¯ - ÐÐµÐ¼ÐµÐ´Ð»ÐµÐ½Ð½Ð¾',
                dringend: 'âš¡ Ð¡Ñ€Ð¾Ñ‡Ð½Ð¾ - Ð¡ÐµÐ³Ð¾Ð´Ð½Ñ',
                normal: 'ðŸ“‹ ÐžÐ±Ñ‹Ñ‡Ð½Ñ‹Ð¹',
                title: 'Ð—Ð°ÐºÐ°Ð· ÑÐ¾Ð·Ð´Ð°Ð½!',
                newJob: 'ÐÐ¾Ð²Ñ‹Ð¹ Ð·Ð°ÐºÐ°Ð·'
            },
            tr: {
                notfall: 'ðŸš¨ ACÄ°L - Hemen',
                dringend: 'âš¡ Acil - BugÃ¼n',
                normal: 'ðŸ“‹ Normal',
                title: 'SipariÅŸ oluÅŸturuldu!',
                newJob: 'Yeni sipariÅŸ'
            },
            en: {
                notfall: 'ðŸš¨ EMERGENCY - Immediate',
                dringend: 'âš¡ Urgent - Today',
                normal: 'ðŸ“‹ Normal',
                title: 'Job created!',
                newJob: 'New job'
            }
        };

        function addJobCreatedMessage(jobData, language = 'de') {
            const msgDiv = document.createElement('div');
            msgDiv.className = 'message job-created';

            const labels = urgencyLabelsI18n[language] || urgencyLabelsI18n.de;

            msgDiv.innerHTML = `
                <div class="job-success-icon">âœ…</div>
                <div class="job-success-title">${labels.title}</div>
                <div class="job-success-number">${jobData.job_number || labels.newJob}</div>
                <div class="job-success-meta">
                    ${labels[jobData.urgency] || ''} â€¢ Elektro
                </div>
            `;
            chat.appendChild(msgDiv);
            chat.scrollTop = chat.scrollHeight;
        }

        // TTS Audio element for backend TTS playback
        let currentAudioElement = null;

        // Speak text using backend TTS API (high-quality natural voice)
        async function speak(text, language = 'de') {
            // Cancel any ongoing speech
            stopSpeaking();

            isSpeaking = true;
            speakingIndicator.classList.add('active');

            try {
                // Call backend TTS endpoint
                const response = await fetch('/api/v1/audio/tts', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        text: text,
                        language: language
                    })
                });

                if (!response.ok) {
                    throw new Error(`TTS request failed: ${response.status}`);
                }

                const ttsEngine = response.headers.get('X-TTS-Engine') || 'unknown';
                const contentType = response.headers.get('Content-Type') || 'audio/mpeg';
                console.log(`Using TTS engine: ${ttsEngine} (${contentType}) for language: ${language}`);

                // Get audio data as blob
                const audioBlob = await response.blob();

                if (audioBlob.size === 0) {
                    console.warn('Empty TTS response, falling back to browser TTS');
                    fallbackSpeak(text, language);
                    return;
                }

                // Create audio URL and play with Audio element
                // This handles both MP3 (ElevenLabs) and WAV (Piper) formats
                const audioUrl = URL.createObjectURL(audioBlob);
                currentAudioElement = new Audio(audioUrl);

                currentAudioElement.onended = () => {
                    isSpeaking = false;
                    speakingIndicator.classList.remove('active');
                    URL.revokeObjectURL(audioUrl);
                    currentAudioElement = null;
                };

                currentAudioElement.onerror = (e) => {
                    console.error('Audio playback error:', e);
                    isSpeaking = false;
                    speakingIndicator.classList.remove('active');
                    URL.revokeObjectURL(audioUrl);
                    currentAudioElement = null;
                    fallbackSpeak(text, language);
                };

                await currentAudioElement.play();

            } catch (error) {
                console.error('Backend TTS failed, falling back to browser TTS:', error);
                fallbackSpeak(text, language);
            }
        }

        // Stop any currently playing TTS audio
        function stopSpeaking() {
            if (currentAudioElement) {
                try {
                    currentAudioElement.pause();
                    currentAudioElement.currentTime = 0;
                } catch (e) {}
                currentAudioElement = null;
            }
            // Also stop browser TTS if it was used as fallback
            if (synth) {
                synth.cancel();
            }
            isSpeaking = false;
            speakingIndicator.classList.remove('active');

            // Don't reset to 'ready' here - let the caller decide
            // This prevents status flickering during transitions
        }

        // Fallback to browser TTS if backend fails
        function fallbackSpeak(text, language = 'de') {
            if (!synth) {
                isSpeaking = false;
                speakingIndicator.classList.remove('active');
                return;
            }

            const langCodeMap = {
                de: 'de-DE',
                ru: 'ru-RU',
                tr: 'tr-TR',
                en: 'en-US'
            };

            const utterance = new SpeechSynthesisUtterance(text);
            const langCode = langCodeMap[language] || 'de-DE';
            utterance.lang = langCode;
            utterance.rate = 1.0;
            utterance.pitch = 1.0;

            const voices = synth.getVoices();
            const targetVoice = voices.find(v => v.lang.startsWith(langCode.split('-')[0]));
            if (targetVoice) {
                utterance.voice = targetVoice;
            }

            utterance.onend = () => {
                isSpeaking = false;
                speakingIndicator.classList.remove('active');
            };

            utterance.onerror = () => {
                isSpeaking = false;
                speakingIndicator.classList.remove('active');
            };

            synth.speak(utterance);
        }

        function toggleRecording() {
            if (isSpeaking) {
                stopSpeaking();
            }

            if (isRecording) {
                recognition.stop();
                conversationActive = false; // User manually stopped
            } else {
                // User manually starting - activate conversation
                conversationActive = true;
                noSpeechRetryCount = 0;
                startListening();
            }
        }

        function stopRecording() {
            isRecording = false;
            micBtn.classList.remove('recording');
            micIcon.textContent = 'ðŸŽ¤';
            micHint.textContent = conversationActive ? 'Ich hÃ¶re gleich wieder...' : 'Zum Sprechen tippen';
            micHint.classList.remove('recording');

            // Update status based on conversation state
            if (!isSpeaking && !conversationActive) {
                updateStatus('ready');
            }
        }

        // Event listeners
        micBtn.addEventListener('click', toggleRecording);

        let holdTimeout;
        micBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            holdTimeout = setTimeout(() => {
                if (!isRecording && !isSpeaking) {
                    toggleRecording();
                }
            }, 100);
        }, { passive: false });

        micBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            clearTimeout(holdTimeout);
        }, { passive: false });

        if (synth) {
            synth.onvoiceschanged = () => {
                const voices = synth.getVoices();
                console.log('Available German voices:', voices.filter(v => v.lang.startsWith('de')).map(v => v.name));
            };
        }

        document.addEventListener('DOMContentLoaded', () => {
            if (initSpeechRecognition()) {
                document.getElementById('statusText').textContent = 'Bereit';
            } else {
                document.getElementById('statusText').textContent = 'Nicht unterstÃ¼tzt';
                document.getElementById('statusDot').style.background = '#fb7185';
            }
        });
    </script>
</body>
</html>
