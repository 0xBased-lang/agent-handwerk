<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Elektro-Notdienst</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Core palette - Industrial Dark */
            --bg-primary: #0a0c0f;
            --bg-secondary: #12151a;
            --bg-tertiary: #1a1e25;
            --bg-elevated: #22272f;

            /* Borders */
            --border-subtle: rgba(255, 255, 255, 0.06);
            --border-default: rgba(255, 255, 255, 0.1);

            /* Text */
            --text-primary: #f0f2f5;
            --text-secondary: #9ca3af;
            --text-muted: #6b7280;
            --text-inverse: #0a0c0f;

            /* Accents */
            --amber-400: #fbbf24;
            --amber-500: #f59e0b;
            --amber-600: #d97706;
            --amber-glow: rgba(251, 191, 36, 0.15);

            --cyan-400: #22d3ee;
            --cyan-500: #06b6d4;
            --cyan-glow: rgba(6, 182, 212, 0.2);

            --emerald-400: #34d399;
            --emerald-500: #10b981;
            --emerald-glow: rgba(16, 185, 129, 0.15);

            --rose-400: #fb7185;
            --rose-500: #f43f5e;
            --rose-glow: rgba(244, 63, 94, 0.15);

            /* Typography */
            --font-sans: 'IBM Plex Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-mono: 'JetBrains Mono', monospace;

            /* Spacing */
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;
            --space-5: 20px;
            --space-6: 24px;

            /* Radii */
            --radius-sm: 6px;
            --radius-md: 10px;
            --radius-lg: 14px;
            --radius-xl: 20px;
            --radius-full: 50%;

            /* Transitions */
            --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-base: 200ms cubic-bezier(0.4, 0, 0.2, 1);
        }

        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: var(--font-sans);
            background: var(--bg-primary);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            -webkit-font-smoothing: antialiased;
        }

        /* Subtle grid pattern */
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
            z-index: -1;
        }

        /* Header */
        .header {
            padding: var(--space-4) var(--space-5);
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }

        .brand-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--amber-500), var(--amber-600));
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.3);
        }

        .brand-text {
            display: flex;
            flex-direction: column;
        }

        .brand-title {
            font-size: 1.1rem;
            font-weight: 700;
            letter-spacing: -0.02em;
        }

        .brand-subtitle {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .status-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border-radius: 20px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: var(--radius-full);
            background: var(--emerald-400);
            animation: pulse-glow 2s ease-in-out infinite;
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 0 0 rgba(52, 211, 153, 0.5); }
            50% { box-shadow: 0 0 0 8px rgba(52, 211, 153, 0); }
        }

        /* Chat area */
        .chat-area {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-4);
            display: flex;
            flex-direction: column;
            gap: var(--space-3);
            -webkit-overflow-scrolling: touch;
        }

        .message {
            max-width: 85%;
            padding: var(--space-3) var(--space-4);
            border-radius: var(--radius-lg);
            font-size: 0.95rem;
            line-height: 1.5;
            animation: message-in 0.3s ease-out;
        }

        @keyframes message-in {
            from { opacity: 0; transform: translateY(12px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.user {
            align-self: flex-end;
            background: linear-gradient(135deg, var(--amber-500), var(--amber-600));
            color: var(--text-inverse);
            border-bottom-right-radius: var(--radius-sm);
        }

        .message.assistant {
            align-self: flex-start;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-subtle);
            border-bottom-left-radius: var(--radius-sm);
        }

        .message.system {
            align-self: center;
            background: var(--bg-secondary);
            border: 1px solid var(--border-subtle);
            font-size: 0.85rem;
            text-align: center;
            color: var(--text-secondary);
            padding: var(--space-3);
        }

        .message.job-created {
            align-self: center;
            background: linear-gradient(135deg, var(--emerald-500), #059669);
            color: white;
            text-align: center;
            padding: var(--space-5);
            max-width: 90%;
            border-radius: var(--radius-lg);
        }

        .job-success-icon {
            font-size: 2.5rem;
            margin-bottom: var(--space-2);
        }

        .job-success-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .job-success-number {
            font-family: var(--font-mono);
            font-size: 0.9rem;
            opacity: 0.9;
            margin-bottom: var(--space-2);
        }

        .job-success-meta {
            font-size: 0.8rem;
            opacity: 0.85;
        }

        .message.error {
            align-self: center;
            background: var(--rose-glow);
            border: 1px solid var(--rose-500);
            color: var(--rose-400);
        }

        /* Quick actions */
        .quick-actions {
            display: flex;
            gap: var(--space-2);
            padding: var(--space-3) var(--space-4);
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-subtle);
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .quick-btn {
            flex-shrink: 0;
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 10px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: 24px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .quick-btn:active {
            transform: scale(0.97);
            background: var(--bg-elevated);
        }

        .quick-btn-icon {
            font-size: 1.1rem;
        }

        /* Mic area */
        .mic-area {
            padding: var(--space-5);
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-subtle);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-4);
        }

        .speaking-indicator {
            display: none;
            align-items: center;
            gap: var(--space-2);
            padding: 8px 16px;
            background: var(--cyan-glow);
            border-radius: 20px;
            font-size: 0.85rem;
            color: var(--cyan-400);
        }

        .speaking-indicator.active {
            display: flex;
        }

        .speaking-waves {
            display: flex;
            gap: 3px;
            height: 18px;
            align-items: center;
        }

        .speaking-wave {
            width: 3px;
            background: var(--cyan-400);
            border-radius: 2px;
            animation: wave 1s ease-in-out infinite;
        }

        .speaking-wave:nth-child(1) { animation-delay: 0s; height: 8px; }
        .speaking-wave:nth-child(2) { animation-delay: 0.1s; height: 14px; }
        .speaking-wave:nth-child(3) { animation-delay: 0.2s; height: 18px; }
        .speaking-wave:nth-child(4) { animation-delay: 0.3s; height: 14px; }
        .speaking-wave:nth-child(5) { animation-delay: 0.4s; height: 8px; }

        @keyframes wave {
            0%, 100% { transform: scaleY(1); }
            50% { transform: scaleY(0.4); }
        }

        .transcript-preview {
            min-height: 20px;
            font-size: 0.85rem;
            color: var(--text-muted);
            text-align: center;
            font-style: italic;
        }

        .mic-button {
            width: 88px;
            height: 88px;
            border-radius: var(--radius-full);
            border: none;
            background: linear-gradient(135deg, var(--rose-500), #dc2626);
            color: white;
            font-size: 2.2rem;
            cursor: pointer;
            transition: all var(--transition-base);
            box-shadow: 0 4px 24px rgba(244, 63, 94, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mic-button:active {
            transform: scale(0.95);
        }

        .mic-button.recording {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            animation: mic-pulse 1.5s ease-in-out infinite;
        }

        @keyframes mic-pulse {
            0% { box-shadow: 0 0 0 0 rgba(244, 63, 94, 0.6); }
            50% { box-shadow: 0 0 0 20px rgba(244, 63, 94, 0); }
            100% { box-shadow: 0 0 0 0 rgba(244, 63, 94, 0); }
        }

        .mic-hint {
            font-size: 0.85rem;
            color: var(--text-muted);
            text-align: center;
        }

        .mic-hint.recording {
            color: var(--rose-400);
            font-weight: 500;
        }

        /* Info form overlay */
        .info-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(10, 12, 15, 0.95);
            backdrop-filter: blur(8px);
            z-index: 100;
            padding: var(--space-5);
            overflow-y: auto;
        }

        .info-overlay.active {
            display: block;
        }

        .info-form {
            max-width: 400px;
            margin: 0 auto;
            padding-top: 20px;
        }

        .form-header {
            text-align: center;
            margin-bottom: var(--space-6);
        }

        .form-header-icon {
            width: 56px;
            height: 56px;
            background: var(--amber-glow);
            border-radius: var(--radius-lg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            margin: 0 auto var(--space-3);
        }

        .form-header h2 {
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .form-header p {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .form-group {
            margin-bottom: var(--space-4);
        }

        .form-group label {
            display: block;
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .form-group input {
            width: 100%;
            padding: 14px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: var(--radius-md);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 1rem;
            transition: all var(--transition-fast);
        }

        .form-group input::placeholder {
            color: var(--text-muted);
        }

        .form-group input:focus {
            outline: none;
            border-color: var(--amber-500);
            box-shadow: 0 0 0 3px var(--amber-glow);
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: var(--space-3);
        }

        .submit-btn {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, var(--emerald-500), #059669);
            border: none;
            border-radius: var(--radius-md);
            color: white;
            font-family: inherit;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-fast);
            margin-top: var(--space-2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
        }

        .submit-btn:active {
            transform: scale(0.98);
        }

        .submit-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .cancel-btn {
            width: 100%;
            padding: 14px;
            background: transparent;
            border: 1px solid var(--border-default);
            border-radius: var(--radius-md);
            color: var(--text-secondary);
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            margin-top: var(--space-3);
            transition: all var(--transition-fast);
        }

        .cancel-btn:active {
            background: var(--bg-tertiary);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-default);
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-left">
            <div class="brand-icon">âš¡</div>
            <div class="brand-text">
                <span class="brand-title">Elektro-Notdienst</span>
                <span class="brand-subtitle">24/7 VerfÃ¼gbar</span>
            </div>
        </div>
        <div class="status-badge">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Bereit</span>
        </div>
    </header>

    <div class="chat-area" id="chat">
        <div class="message system">
            Tippen Sie auf das Mikrofon und beschreiben Sie Ihr Anliegen.
        </div>
    </div>

    <div class="quick-actions">
        <button class="quick-btn" onclick="processUserInput('Ich habe einen Stromausfall im ganzen Haus')">
            <span class="quick-btn-icon">ðŸ”Œ</span>
            <span>Stromausfall</span>
        </button>
        <button class="quick-btn" onclick="processUserInput('Meine Steckdose raucht und riecht verbrannt')">
            <span class="quick-btn-icon">ðŸš¨</span>
            <span>Notfall</span>
        </button>
        <button class="quick-btn" onclick="processUserInput('Die Sicherung fliegt immer wieder raus')">
            <span class="quick-btn-icon">âš¡</span>
            <span>Sicherung</span>
        </button>
    </div>

    <div class="mic-area">
        <div class="speaking-indicator" id="speakingIndicator">
            <div class="speaking-waves">
                <div class="speaking-wave"></div>
                <div class="speaking-wave"></div>
                <div class="speaking-wave"></div>
                <div class="speaking-wave"></div>
                <div class="speaking-wave"></div>
            </div>
            <span>Antwortet...</span>
        </div>
        <div class="transcript-preview" id="transcriptPreview"></div>
        <button class="mic-button" id="micBtn">
            <span id="micIcon">ðŸŽ¤</span>
        </button>
        <div class="mic-hint" id="micHint">Zum Sprechen tippen</div>
    </div>

    <!-- Customer Info Form Overlay -->
    <div class="info-overlay" id="infoOverlay">
        <div class="info-form">
            <div class="form-header">
                <div class="form-header-icon">ðŸ“‹</div>
                <h2>Kontaktdaten</h2>
                <p>FÃ¼r die Auftragserstellung benÃ¶tigen wir einige Informationen.</p>
            </div>

            <div class="form-group">
                <label for="customerName">Name *</label>
                <input type="text" id="customerName" placeholder="Max Mustermann" required>
            </div>

            <div class="form-group">
                <label for="customerPhone">Telefon</label>
                <input type="tel" id="customerPhone" placeholder="+49 170 1234567">
            </div>

            <div class="form-group">
                <label for="customerStreet">StraÃŸe & Hausnummer *</label>
                <input type="text" id="customerStreet" placeholder="MusterstraÃŸe 42">
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label for="customerZip">PLZ *</label>
                    <input type="text" id="customerZip" placeholder="10115" pattern="[0-9]{5}">
                </div>
                <div class="form-group">
                    <label for="customerCity">Stadt *</label>
                    <input type="text" id="customerCity" placeholder="Berlin">
                </div>
            </div>

            <button class="submit-btn" id="submitInfoBtn" onclick="submitCustomerInfo()">
                <span>âœ…</span>
                <span>Auftrag erstellen</span>
            </button>
            <button class="cancel-btn" onclick="hideInfoForm()">Abbrechen</button>
        </div>
    </div>

    <script>
        // State
        let recognition = null;
        let synth = window.speechSynthesis;
        let isRecording = false;
        let isSpeaking = false;
        let isProcessing = false;  // CRITICAL: Lock to prevent multiple simultaneous responses
        let conversationHistory = [];
        let pendingJobDescription = '';
        let currentLanguage = 'de';  // Current detected language
        let formShownThisSession = false; // Don't show form multiple times
        let conversationActive = false;  // Track if conversation is ongoing
        let lastProcessedText = '';  // Debounce: track last processed text
        let lastProcessedTime = 0;   // Debounce: track last processed time
        const DEBOUNCE_MS = 2000;    // Ignore duplicate texts within 2 seconds

        // Backend-driven conversation state
        let sessionId = 'session-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        let conversationState = 'greeting';  // From backend
        let detectedUrgency = 'normal';  // From backend
        let detectedTrade = null;  // From backend

        // DOM Elements
        const chat = document.getElementById('chat');
        const micBtn = document.getElementById('micBtn');
        const micIcon = document.getElementById('micIcon');
        const micHint = document.getElementById('micHint');
        const transcriptPreview = document.getElementById('transcriptPreview');
        const speakingIndicator = document.getElementById('speakingIndicator');
        const infoOverlay = document.getElementById('infoOverlay');

        // Language detection patterns
        const CYRILLIC_PATTERN = /[\u0400-\u04FF]/;
        const TURKISH_CHARS = /[ÅŸÅžÄŸÄžÄ±Ä°Ã§Ã‡]/;
        const SCHWAEBISCH_PATTERNS = [
            /\bbissle\b/i, /\bmÃ¤dle\b/i, /\bhÃ¤usle\b/i, /\bnet\b/i,
            /\bi\s+hab/i, /\bgell\b/i, /\bgang\b/i, /\bschaffe\b/i
        ];
        // English detection patterns (common English words/phrases)
        const ENGLISH_PATTERNS = [
            /\b(hello|hi|hey)\b/i,
            /\b(I have|I need|I want|I am|I'm)\b/i,
            /\b(please|thank you|thanks)\b/i,
            /\b(power outage|no power|electricity|electrical)\b/i,
            /\b(help|problem|issue|broken|repair)\b/i,
            /\b(appointment|schedule|today|tomorrow)\b/i,
            /\b(the|and|or|but|with|for)\b/i
        ];

        // === TIMEOUT & SAFETY UTILITIES ===
        const FETCH_TIMEOUT_MS = 30000;  // 30 second timeout for API calls
        const PROCESSING_SAFETY_TIMEOUT_MS = 60000;  // 60 second safety timeout
        let processingStartTime = 0;

        // Fetch with timeout wrapper - prevents hanging on slow/dead APIs
        async function fetchWithTimeout(url, options, timeout = FETCH_TIMEOUT_MS) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);

            try {
                const response = await fetch(url, {
                    ...options,
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                return response;
            } catch (error) {
                clearTimeout(timeoutId);
                if (error.name === 'AbortError') {
                    throw new Error(`Request timeout after ${timeout}ms`);
                }
                throw error;
            }
        }

        // Safety function to force-release locks if stuck too long
        function checkAndReleaseStaleLock() {
            if (isProcessing && processingStartTime > 0) {
                const elapsed = Date.now() - processingStartTime;
                if (elapsed > PROCESSING_SAFETY_TIMEOUT_MS) {
                    console.warn(`SAFETY: Force-releasing stale lock after ${elapsed}ms`);
                    isProcessing = false;
                    isSpeaking = false;
                    processingStartTime = 0;
                    updateStatus('ready');
                    addMessage('system', 'Verbindung unterbrochen. Bitte erneut sprechen.');
                    return true;
                }
            }
            return false;
        }

        // Run safety check every 10 seconds
        setInterval(checkAndReleaseStaleLock, 10000);

        // Detect language from text
        function detectLanguage(text) {
            // Check for Cyrillic (Russian)
            if (CYRILLIC_PATTERN.test(text)) {
                return 'ru';
            }
            // Check for Turkish-specific characters
            if (TURKISH_CHARS.test(text)) {
                return 'tr';
            }
            // Check for SchwÃ¤bisch dialect (respond in German)
            const schwÃ¤bischMatches = SCHWAEBISCH_PATTERNS.filter(p => p.test(text)).length;
            if (schwÃ¤bischMatches >= 1) {
                return 'de';  // Understand but respond in standard German
            }
            // Check for English patterns
            const englishMatches = ENGLISH_PATTERNS.filter(p => p.test(text)).length;
            if (englishMatches >= 2) {
                return 'en';
            }
            return 'de';
        }

        // Multilingual responses - conversation flow with initial inquiry and follow-up
        const responses = {
            de: {
                emergency: {
                    keywords: ['raucht', 'brennt', 'feuer', 'funken', 'brand', 'stromschlag', 'explosion'],
                    // First response asks for more info, follow-up offers job creation
                    initial: 'ACHTUNG! Das klingt nach einem Notfall. Sind Sie in Sicherheit? Haben Sie die Hauptsicherung bereits ausgeschaltet?',
                    followup: 'Verstanden. Wir schicken sofort einen Techniker. Ich brauche nur noch Ihre Kontaktdaten.',
                    urgency: 'notfall',
                    showFormAfterTurns: 1  // Show form after 1 turn for emergencies
                },
                urgent: {
                    keywords: ['stromausfall', 'kein strom', 'sicherung', 'fi schalter', 'dunkel', 'kein licht'],
                    initial: 'Verstanden - Sie haben ein Stromproblem. Betrifft es das ganze Haus oder nur bestimmte RÃ¤ume?',
                    followup: 'Alles klar. Wir kÃ¶nnen heute noch einen Techniker schicken. Darf ich Ihre Kontaktdaten aufnehmen?',
                    urgency: 'dringend',
                    showFormAfterTurns: 2
                },
                normal: {
                    keywords: ['steckdose', 'kaputt', 'funktioniert nicht', 'defekt', 'reparatur', 'termin'],
                    initial: 'Ich verstehe, Sie haben ein elektrisches Problem. KÃ¶nnen Sie mir mehr dazu erzÃ¤hlen? Seit wann besteht das Problem?',
                    followup: 'Danke fÃ¼r die Details. Wir kÃ¶nnen einen Termin fÃ¼r Sie vereinbaren. Darf ich Ihre Kontaktdaten aufnehmen?',
                    urgency: 'normal',
                    showFormAfterTurns: 2
                },
                fallback: 'Ich verstehe. KÃ¶nnen Sie mir mehr Details geben? Handelt es sich um ein elektrisches Problem?',
                // Generic follow-up when problem is understood
                genericFollowup: 'Danke fÃ¼r die Information. Sollen wir einen Techniker schicken? Ich brÃ¤uchte dann Ihre Kontaktdaten.'
            },
            ru: {
                emergency: {
                    keywords: ['Ð´Ñ‹Ð¼', 'Ð³Ð¾Ñ€Ð¸Ñ‚', 'Ð¾Ð³Ð¾Ð½ÑŒ', 'Ð¸ÑÐºÑ€Ñ‹', 'Ð¿Ð¾Ð¶Ð°Ñ€', 'ÑƒÐ´Ð°Ñ€ Ñ‚Ð¾ÐºÐ¾Ð¼', 'Ð²Ð·Ñ€Ñ‹Ð²', 'Ð´Ñ‹Ð¼Ð¸Ñ‚'],
                    initial: 'Ð’ÐÐ˜ÐœÐÐÐ˜Ð•! Ð­Ñ‚Ð¾ Ð·Ð²ÑƒÑ‡Ð¸Ñ‚ ÐºÐ°Ðº Ð°Ð²Ð°Ñ€Ð¸Ð¹Ð½Ð°Ñ ÑÐ¸Ñ‚ÑƒÐ°Ñ†Ð¸Ñ. Ð’Ñ‹ Ð² Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑ‚Ð¸? Ð’Ñ‹ ÑƒÐ¶Ðµ Ð¾Ñ‚ÐºÐ»ÑŽÑ‡Ð¸Ð»Ð¸ Ð³Ð»Ð°Ð²Ð½Ñ‹Ð¹ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚?',
                    followup: 'ÐŸÐ¾Ð½ÑÐ». ÐœÑ‹ ÑÑ€Ð°Ð·Ñƒ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ð¼ Ñ‚ÐµÑ…Ð½Ð¸ÐºÐ°. ÐœÐ½Ðµ Ð½ÑƒÐ¶Ð½Ñ‹ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð²Ð°ÑˆÐ¸ ÐºÐ¾Ð½Ñ‚Ð°ÐºÑ‚Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ.',
                    urgency: 'notfall',
                    showFormAfterTurns: 1
                },
                urgent: {
                    keywords: ['Ð½ÐµÑ‚ ÑÐ»ÐµÐºÑ‚Ñ€Ð¸Ñ‡ÐµÑÑ‚Ð²Ð°', 'Ð¾Ñ‚ÐºÐ»ÑŽÑ‡Ð¸Ð»ÑÑ ÑÐ²ÐµÑ‚', 'Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚', 'Ð²Ñ‹Ð±Ð¸Ð²Ð°ÐµÑ‚', 'Ñ‚ÐµÐ¼Ð½Ð¾', 'Ð½ÐµÑ‚ ÑÐ²ÐµÑ‚Ð°'],
                    initial: 'ÐŸÐ¾Ð½ÑÐ» - Ñƒ Ð²Ð°Ñ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ð° Ñ ÑÐ»ÐµÐºÑ‚Ñ€Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾Ð¼. Ð­Ñ‚Ð¾ ÐºÐ°ÑÐ°ÐµÑ‚ÑÑ Ð²ÑÐµÐ³Ð¾ Ð´Ð¾Ð¼Ð° Ð¸Ð»Ð¸ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð½ÐµÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ñ… ÐºÐ¾Ð¼Ð½Ð°Ñ‚?',
                    followup: 'ÐŸÐ¾Ð½ÑÑ‚Ð½Ð¾. ÐœÑ‹ Ð¼Ð¾Ð¶ÐµÐ¼ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ Ñ‚ÐµÑ…Ð½Ð¸ÐºÐ° ÑÐµÐ³Ð¾Ð´Ð½Ñ. ÐœÐ¾Ð³Ñƒ Ñ Ð·Ð°Ð¿Ð¸ÑÐ°Ñ‚ÑŒ Ð²Ð°ÑˆÐ¸ ÐºÐ¾Ð½Ñ‚Ð°ÐºÑ‚Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ?',
                    urgency: 'dringend',
                    showFormAfterTurns: 2
                },
                normal: {
                    keywords: ['Ñ€Ð¾Ð·ÐµÑ‚ÐºÐ°', 'ÑÐ»Ð¾Ð¼Ð°Ð»Ð¾ÑÑŒ', 'Ð½Ðµ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚', 'Ñ€ÐµÐ¼Ð¾Ð½Ñ‚', 'Ð·Ð°Ð¿Ð¸ÑÐ°Ñ‚ÑŒÑÑ'],
                    initial: 'ÐŸÐ¾Ð½Ð¸Ð¼Ð°ÑŽ, Ñƒ Ð²Ð°Ñ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ð° Ñ ÑÐ»ÐµÐºÑ‚Ñ€Ð¸ÐºÐ¾Ð¹. Ð Ð°ÑÑÐºÐ°Ð¶Ð¸Ñ‚Ðµ Ð¿Ð¾Ð´Ñ€Ð¾Ð±Ð½ÐµÐµ. ÐšÐ¾Ð³Ð´Ð° ÑÑ‚Ð¾ Ð½Ð°Ñ‡Ð°Ð»Ð¾ÑÑŒ?',
                    followup: 'Ð¡Ð¿Ð°ÑÐ¸Ð±Ð¾ Ð·Ð° Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ. ÐœÑ‹ Ð¼Ð¾Ð¶ÐµÐ¼ Ð½Ð°Ð·Ð½Ð°Ñ‡Ð¸Ñ‚ÑŒ Ð²ÑÑ‚Ñ€ÐµÑ‡Ñƒ. ÐœÐ¾Ð³Ñƒ Ñ Ð·Ð°Ð¿Ð¸ÑÐ°Ñ‚ÑŒ Ð²Ð°ÑˆÐ¸ ÐºÐ¾Ð½Ñ‚Ð°ÐºÑ‚Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ?',
                    urgency: 'normal',
                    showFormAfterTurns: 2
                },
                fallback: 'ÐŸÐ¾Ð½Ð¸Ð¼Ð°ÑŽ. ÐœÐ¾Ð¶ÐµÑ‚Ðµ Ð´Ð°Ñ‚ÑŒ Ð±Ð¾Ð»ÑŒÑˆÐµ Ð´ÐµÑ‚Ð°Ð»ÐµÐ¹? Ð­Ñ‚Ð¾ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ð° Ñ ÑÐ»ÐµÐºÑ‚Ñ€Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾Ð¼?',
                genericFollowup: 'Ð¡Ð¿Ð°ÑÐ¸Ð±Ð¾ Ð·Ð° Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ. Ð¥Ð¾Ñ‚Ð¸Ñ‚Ðµ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¼Ñ‹ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ð»Ð¸ Ñ‚ÐµÑ…Ð½Ð¸ÐºÐ°? Ð¢Ð¾Ð³Ð´Ð° Ð¼Ð½Ðµ Ð½ÑƒÐ¶Ð½Ñ‹ Ð²Ð°ÑˆÐ¸ ÐºÐ¾Ð½Ñ‚Ð°ÐºÑ‚Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ.'
            },
            tr: {
                emergency: {
                    keywords: ['duman', 'yanÄ±yor', 'ateÅŸ', 'kÄ±vÄ±lcÄ±m', 'yangÄ±n', 'elektrik Ã§arpmasÄ±', 'patlama'],
                    initial: 'DÄ°KKAT! Bu acil bir durum gibi gÃ¶rÃ¼nÃ¼yor. GÃ¼vende misiniz? Ana sigortayÄ± kapattÄ±nÄ±z mÄ±?',
                    followup: 'AnladÄ±m. Hemen bir teknisyen gÃ¶nderiyoruz. Sadece iletiÅŸim bilgilerinize ihtiyacÄ±m var.',
                    urgency: 'notfall',
                    showFormAfterTurns: 1
                },
                urgent: {
                    keywords: ['elektrik kesintisi', 'elektrik yok', 'sigorta', 'karanlÄ±k', 'Ä±ÅŸÄ±k yok'],
                    initial: 'AnladÄ±m - elektrik sorununuz var. TÃ¼m evi mi etkiliyor yoksa sadece bazÄ± odalarÄ± mÄ±?',
                    followup: 'Tamam. BugÃ¼n bir teknisyen gÃ¶nderebiliriz. Ä°letiÅŸim bilgilerinizi alabilir miyim?',
                    urgency: 'dringend',
                    showFormAfterTurns: 2
                },
                normal: {
                    keywords: ['priz', 'bozuk', 'Ã§alÄ±ÅŸmÄ±yor', 'tamir', 'randevu'],
                    initial: 'AnlÄ±yorum, elektrikle ilgili bir sorununuz var. Daha fazla bilgi verebilir misiniz? Ne zamandan beri var?',
                    followup: 'Bilgi iÃ§in teÅŸekkÃ¼rler. Size randevu ayarlayabiliriz. Ä°letiÅŸim bilgilerinizi alabilir miyim?',
                    urgency: 'normal',
                    showFormAfterTurns: 2
                },
                fallback: 'AnlÄ±yorum. Daha fazla detay verebilir misiniz? Bu bir elektrik sorunu mu?',
                genericFollowup: 'Bilgi iÃ§in teÅŸekkÃ¼rler. Teknisyen gÃ¶ndermemizi ister misiniz? O zaman iletiÅŸim bilgilerinize ihtiyacÄ±m var.'
            },
            en: {
                emergency: {
                    keywords: ['smoke', 'burning', 'fire', 'sparks', 'explosion', 'shock', 'electrocuted'],
                    initial: 'ALERT! This sounds like an emergency. Are you safe? Have you switched off the main breaker?',
                    followup: 'Understood. We will send someone immediately. I just need your contact details.',
                    urgency: 'notfall',
                    showFormAfterTurns: 1
                },
                urgent: {
                    keywords: ['power outage', 'no power', 'no electricity', 'breaker', 'dark', 'no light', 'blackout'],
                    initial: 'Understood - you have a power problem. Is it affecting the whole house or just certain rooms?',
                    followup: 'Got it. We can send a technician today. May I take your contact details?',
                    urgency: 'dringend',
                    showFormAfterTurns: 2
                },
                normal: {
                    keywords: ['outlet', 'socket', 'broken', 'not working', 'repair', 'appointment', 'schedule'],
                    initial: 'I understand, you have an electrical issue. Can you tell me more? When did this start?',
                    followup: 'Thanks for the details. We can schedule an appointment. May I take your contact details?',
                    urgency: 'normal',
                    showFormAfterTurns: 2
                },
                fallback: 'I understand. Can you give me more details? Is this an electrical problem?',
                genericFollowup: 'Thanks for the information. Would you like us to send a technician? I would need your contact details.'
            }
        };

        // UI text translations
        const uiText = {
            de: {
                ready: 'Bereit',
                listening: 'Ich hÃ¶re...',
                tapToSpeak: 'Zum Sprechen tippen',
                creatingJob: 'Auftrag wird erstellt...',
                fillRequired: 'Bitte fÃ¼llen Sie alle Pflichtfelder aus.',
                jobCreated: 'Auftrag erstellt!',
                notSupported: 'Nicht unterstÃ¼tzt',
                noSpeech: 'Keine Sprache erkannt. Bitte versuchen Sie es erneut.',
                micDenied: 'Mikrofon-Zugriff verweigert. Bitte erlauben Sie den Zugriff.'
            },
            ru: {
                ready: 'Ð“Ð¾Ñ‚Ð¾Ð²',
                listening: 'Ð¡Ð»ÑƒÑˆÐ°ÑŽ...',
                tapToSpeak: 'ÐÐ°Ð¶Ð¼Ð¸Ñ‚Ðµ Ð´Ð»Ñ Ð·Ð°Ð¿Ð¸ÑÐ¸',
                creatingJob: 'Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð·Ð°ÐºÐ°Ð·Ð°...',
                fillRequired: 'ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð·Ð°Ð¿Ð¾Ð»Ð½Ð¸Ñ‚Ðµ Ð²ÑÐµ Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ð¿Ð¾Ð»Ñ.',
                jobCreated: 'Ð—Ð°ÐºÐ°Ð· ÑÐ¾Ð·Ð´Ð°Ð½!',
                notSupported: 'ÐÐµ Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÑ‚ÑÑ',
                noSpeech: 'Ð ÐµÑ‡ÑŒ Ð½Ðµ Ñ€Ð°ÑÐ¿Ð¾Ð·Ð½Ð°Ð½Ð°. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ ÑÐ½Ð¾Ð²Ð°.',
                micDenied: 'Ð”Ð¾ÑÑ‚ÑƒÐ¿ Ðº Ð¼Ð¸ÐºÑ€Ð¾Ñ„Ð¾Ð½Ñƒ Ð·Ð°Ð¿Ñ€ÐµÑ‰Ñ‘Ð½. ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ñ€Ð°Ð·Ñ€ÐµÑˆÐ¸Ñ‚Ðµ Ð´Ð¾ÑÑ‚ÑƒÐ¿.'
            },
            tr: {
                ready: 'HazÄ±r',
                listening: 'Dinliyorum...',
                tapToSpeak: 'KonuÅŸmak iÃ§in dokunun',
                creatingJob: 'SipariÅŸ oluÅŸturuluyor...',
                fillRequired: 'LÃ¼tfen tÃ¼m zorunlu alanlarÄ± doldurun.',
                jobCreated: 'SipariÅŸ oluÅŸturuldu!',
                notSupported: 'Desteklenmiyor',
                noSpeech: 'KonuÅŸma algÄ±lanamadÄ±. LÃ¼tfen tekrar deneyin.',
                micDenied: 'Mikrofon eriÅŸimi reddedildi. LÃ¼tfen eriÅŸime izin verin.'
            },
            en: {
                ready: 'Ready',
                listening: 'Listening...',
                tapToSpeak: 'Tap to speak',
                creatingJob: 'Creating job...',
                fillRequired: 'Please fill in all required fields.',
                jobCreated: 'Job created!',
                notSupported: 'Not supported',
                noSpeech: 'No speech detected. Please try again.',
                micDenied: 'Microphone access denied. Please allow access.'
            }
        };

        // Initialize Speech Recognition with continuous conversation support
        function initSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                addMessage('error', 'Spracherkennung wird nicht unterstÃ¼tzt. Bitte verwenden Sie Chrome oder Safari.');
                return false;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.lang = 'de-DE';
            recognition.continuous = false;  // FIXED: Single-shot mode prevents duplicate results
            recognition.interimResults = true;
            recognition.maxAlternatives = 1;

            recognition.onstart = () => {
                isRecording = true;
                micBtn.classList.add('recording');
                micIcon.textContent = 'ðŸ”´';
                micHint.textContent = 'Ich hÃ¶re...';
                micHint.classList.add('recording');
                transcriptPreview.textContent = '';
                updateStatus('listening');
                console.log('Speech recognition started');
            };

            recognition.onresult = (event) => {
                const result = event.results[event.results.length - 1];
                const transcript = result[0].transcript.trim();

                if (result.isFinal && transcript) {
                    transcriptPreview.textContent = '';

                    // CRITICAL: Debounce - ignore if same text within 2 seconds
                    const now = Date.now();
                    if (transcript === lastProcessedText && (now - lastProcessedTime) < DEBOUNCE_MS) {
                        console.log('DEBOUNCE: Ignoring duplicate text:', transcript.substring(0, 30));
                        return;
                    }

                    // CRITICAL: Lock check - ignore if already processing
                    if (isProcessing) {
                        console.log('LOCKED: Ignoring input while processing:', transcript.substring(0, 30));
                        return;
                    }

                    lastProcessedText = transcript;
                    lastProcessedTime = now;
                    processUserInput(transcript);
                } else {
                    transcriptPreview.textContent = transcript;
                }
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);

                if (event.error === 'not-allowed') {
                    addMessage('error', 'Mikrofon-Zugriff verweigert. Bitte erlauben Sie den Zugriff.');
                } else if (event.error === 'no-speech') {
                    // Silent - just stop, user can tap again
                    console.log('No speech detected');
                } else if (event.error === 'aborted') {
                    console.log('Recognition aborted');
                } else if (event.error === 'network') {
                    addMessage('system', 'Netzwerkfehler. Bitte prÃ¼fen Sie Ihre Verbindung.');
                }

                stopRecording();
            };

            recognition.onend = () => {
                console.log('Recognition ended, isProcessing:', isProcessing);
                stopRecording();
                // Don't auto-restart here - let TTS completion handle it
            };

            return true;
        }

        // Update status indicator
        function updateStatus(state) {
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');

            switch(state) {
                case 'listening':
                    statusDot.style.background = '#f43f5e'; // Red for recording
                    statusText.textContent = 'HÃ¶re zu...';
                    break;
                case 'speaking':
                    statusDot.style.background = '#06b6d4'; // Cyan for AI speaking
                    statusText.textContent = 'Antwortet...';
                    break;
                case 'processing':
                    statusDot.style.background = '#f59e0b'; // Amber for processing
                    statusText.textContent = 'Verarbeite...';
                    break;
                case 'ready':
                default:
                    statusDot.style.background = '#34d399'; // Green for ready
                    statusText.textContent = 'Bereit';
                    break;
            }
        }

        // Start listening
        function startListening() {
            if (isSpeaking || isProcessing) {
                console.log('Cannot start: speaking or processing');
                return false;
            }

            if (isRecording) {
                console.log('Already listening');
                return true;
            }

            conversationActive = true;

            try {
                recognition.start();
                return true;
            } catch (e) {
                console.error('Failed to start recognition:', e);
                return false;
            }
        }

        // Stop listening
        function stopListening() {
            if (recognition) {
                try {
                    recognition.stop();
                } catch (e) {
                    // Ignore
                }
            }
        }

        // Process user input using backend AI conversation API
        async function processUserInput(text) {
            // CRITICAL: Set processing lock immediately
            isProcessing = true;
            processingStartTime = Date.now();  // Track start time for safety timeout
            console.log('Processing input:', text.substring(0, 50));

            addMessage('user', text);

            // Mark conversation as active
            conversationActive = true;
            updateStatus('processing');

            // Accumulate job description across turns
            if (pendingJobDescription) {
                pendingJobDescription += ' | ' + text;
            } else {
                pendingJobDescription = text;
            }

            // Detect language for client-side display (backend handles conversation)
            const detectedLang = detectLanguage(text);
            currentLanguage = detectedLang;

            console.log(`Session: ${sessionId}, Language: ${detectedLang}, State: ${conversationState}`);

            let responseText = '';
            let readyForContact = false;

            try {
                // Call backend conversation API with timeout
                const response = await fetchWithTimeout('/api/v1/audio/conversation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: sessionId,
                        message: text,
                        language: detectedLang
                    })
                }, FETCH_TIMEOUT_MS);

                if (response.ok) {
                    const data = await response.json();
                    responseText = data.response;
                    conversationState = data.conversation_state;
                    readyForContact = data.ready_for_contact;
                    detectedUrgency = data.urgency;
                    detectedTrade = data.detected_trade;

                    console.log(`Backend response - State: ${conversationState}, ReadyForContact: ${readyForContact}, Urgency: ${detectedUrgency}`);
                } else {
                    // Fallback if API fails
                    console.warn('Conversation API failed, using fallback');
                    const fallback = getFallbackResponse(text, detectedLang, conversationHistory.length);
                    responseText = fallback.response;
                    readyForContact = fallback.readyForContact;
                    detectedUrgency = fallback.urgency;
                }
            } catch (error) {
                console.error('Conversation API error:', error);
                const fallback = getFallbackResponse(text, detectedLang, conversationHistory.length);
                responseText = fallback.response;
                readyForContact = fallback.readyForContact;
                detectedUrgency = fallback.urgency;
            }

            // Store conversation context - both user and assistant messages
            conversationHistory.push({
                role: 'user',
                content: text,
                urgency: detectedUrgency,
                language: detectedLang,
                timestamp: new Date().toISOString()
            });
            conversationHistory.push({
                role: 'assistant',
                content: responseText,
                language: detectedLang,
                timestamp: new Date().toISOString()
            });

            // Show response and speak it
            setTimeout(() => {
                addMessage('assistant', responseText);

                // Speak the response, then optionally show form after TTS completes
                speakWithCallback(responseText, detectedLang, () => {
                    // Only show form if ready AND not already shown
                    if (readyForContact && !formShownThisSession) {
                        // Small delay after TTS completes before showing form
                        setTimeout(() => {
                            showInfoForm();
                            formShownThisSession = true;
                        }, 500);
                    }
                });
            }, 500);
        }

        // Fallback responses when API is unavailable
        // Returns {response, readyForContact, urgency}
        function getFallbackResponse(text, language, turnCount) {
            const textLower = text.toLowerCase();
            const langResponses = responses[language] || responses.de;

            // Check each urgency level in order: emergency â†’ urgent â†’ normal
            for (const urgencyType of ['emergency', 'urgent', 'normal']) {
                const data = langResponses[urgencyType];
                if (data && data.keywords.some(kw => textLower.includes(kw.toLowerCase()))) {
                    // Emergency: show form immediately
                    if (urgencyType === 'emergency') {
                        return {
                            response: data.followup,
                            readyForContact: true,
                            urgency: data.urgency
                        };
                    }
                    // Urgent/normal: show form after 4+ turns
                    const ready = turnCount >= 4;
                    return {
                        response: ready ? data.followup : data.initial,
                        readyForContact: ready && !formShownThisSession,
                        urgency: data.urgency
                    };
                }
            }

            // No keywords: ask for more info, show form after 5 turns
            const ready = turnCount >= 5;
            return {
                response: ready ? langResponses.genericFollowup : langResponses.fallback,
                readyForContact: ready && !formShownThisSession,
                urgency: 'normal'
            };
        }

        // Speak with callback when finished (for conversation flow)
        function speakWithCallback(text, language, onComplete) {
            // Cancel any ongoing speech
            stopSpeaking();

            // CRITICAL: Set isSpeaking=true BEFORE stopping recognition
            // This prevents recognition.onend from trying to restart during TTS
            isSpeaking = true;
            speakingIndicator.classList.add('active');
            updateStatus('speaking');
            console.log('=== TTS STARTING, pausing recognition');

            // NOW pause recognition (onend will see isSpeaking=true and wait)
            if (recognition && isRecording) {
                try {
                    recognition.stop();
                    console.log('Paused recognition for TTS');
                } catch (e) {
                    // Ignore errors
                }
            }

            // Helper to handle completion - auto-restart listening
            const handleTTSComplete = () => {
                console.log('TTS complete, releasing lock');
                isSpeaking = false;
                isProcessing = false;  // CRITICAL: Release processing lock
                processingStartTime = 0;  // Reset safety timer
                speakingIndicator.classList.remove('active');

                // Execute callback (may show form)
                if (onComplete) onComplete();

                // Auto-restart listening for seamless conversation
                if (conversationActive && !infoOverlay.classList.contains('active')) {
                    // Delay slightly then restart
                    setTimeout(() => {
                        console.log('Auto-restart check:', {
                            isProcessing, isSpeaking, isRecording,
                            hasRecognition: !!recognition,
                            conversationActive
                        });

                        if (!isProcessing && !isSpeaking && !isRecording && recognition) {
                            try {
                                recognition.start();
                                console.log('Auto-restarted listening after TTS');
                            } catch (e) {
                                console.error('Could not auto-restart recognition:', e.message);
                                // Try to reinitialize recognition
                                if (initSpeechRecognition()) {
                                    try {
                                        recognition.start();
                                        console.log('Restarted after reinit');
                                    } catch (e2) {
                                        console.error('Reinit also failed:', e2.message);
                                        updateStatus('ready');
                                        addMessage('system', 'Spracherkennung neu starten - bitte auf Mikrofon tippen.');
                                    }
                                } else {
                                    updateStatus('ready');
                                }
                            }
                        } else {
                            console.log('Auto-restart skipped - conditions not met');
                            if (!recognition) {
                                addMessage('system', 'Spracherkennung nicht verfÃ¼gbar - bitte auf Mikrofon tippen.');
                            }
                            updateStatus('ready');
                        }
                    }, 500);
                } else {
                    updateStatus('ready');
                }
            };

            // Try backend TTS first (with timeout)
            fetchWithTimeout('/api/v1/audio/tts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text: text, language: language })
            }, FETCH_TIMEOUT_MS)
            .then(response => {
                if (!response.ok) throw new Error('TTS failed');
                return response.blob();
            })
            .then(audioBlob => {
                if (audioBlob.size === 0) throw new Error('Empty audio');

                const audioUrl = URL.createObjectURL(audioBlob);
                currentAudioElement = new Audio(audioUrl);

                currentAudioElement.onended = () => {
                    URL.revokeObjectURL(audioUrl);
                    currentAudioElement = null;
                    handleTTSComplete();
                };

                currentAudioElement.onerror = () => {
                    URL.revokeObjectURL(audioUrl);
                    currentAudioElement = null;
                    // Fallback to browser TTS
                    fallbackSpeakWithCallback(text, language, handleTTSComplete);
                };

                currentAudioElement.play().catch(err => {
                    console.error('Audio play failed:', err);
                    URL.revokeObjectURL(audioUrl);
                    fallbackSpeakWithCallback(text, language, handleTTSComplete);
                });
            })
            .catch((err) => {
                console.error('TTS fetch failed:', err);
                // Fallback to browser TTS
                fallbackSpeakWithCallback(text, language, handleTTSComplete);
            });
        }

        // Fallback browser TTS with callback
        function fallbackSpeakWithCallback(text, language, onComplete) {
            if (!synth) {
                isSpeaking = false;
                isProcessing = false;  // Release lock
                processingStartTime = 0;  // Reset safety timer
                speakingIndicator.classList.remove('active');
                updateStatus('ready');
                if (onComplete) onComplete();
                return;
            }

            const langCodeMap = { de: 'de-DE', ru: 'ru-RU', tr: 'tr-TR', en: 'en-US' };
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = langCodeMap[language] || 'de-DE';
            utterance.rate = 1.0;
            utterance.pitch = 1.0;

            utterance.onend = () => {
                isSpeaking = false;
                speakingIndicator.classList.remove('active');
                if (onComplete) onComplete();
            };

            utterance.onerror = () => {
                isSpeaking = false;
                speakingIndicator.classList.remove('active');
                if (onComplete) onComplete();
            };

            synth.speak(utterance);
        }

        // Multilingual success messages
        const successMessages = {
            de: {
                created: (jobNum) => `Ihr Auftrag ${jobNum} wurde erstellt.`,
                notfall: 'Ein Techniker ist bereits unterwegs!',
                dringend: 'Wir rufen Sie innerhalb der nÃ¤chsten Stunde an.',
                normal: 'Wir melden uns schnellstmÃ¶glich bei Ihnen.'
            },
            ru: {
                created: (jobNum) => `Ð’Ð°Ñˆ Ð·Ð°ÐºÐ°Ð· ${jobNum} ÑÐ¾Ð·Ð´Ð°Ð½.`,
                notfall: 'Ð¢ÐµÑ…Ð½Ð¸Ðº ÑƒÐ¶Ðµ Ð² Ð¿ÑƒÑ‚Ð¸!',
                dringend: 'ÐœÑ‹ Ð¿Ð¾Ð·Ð²Ð¾Ð½Ð¸Ð¼ Ð²Ð°Ð¼ Ð² Ñ‚ÐµÑ‡ÐµÐ½Ð¸Ðµ Ñ‡Ð°ÑÐ°.',
                normal: 'ÐœÑ‹ ÑÐ²ÑÐ¶ÐµÐ¼ÑÑ Ñ Ð²Ð°Ð¼Ð¸ Ð² Ð±Ð»Ð¸Ð¶Ð°Ð¹ÑˆÐµÐµ Ð²Ñ€ÐµÐ¼Ñ.'
            },
            tr: {
                created: (jobNum) => `SipariÅŸiniz ${jobNum} oluÅŸturuldu.`,
                notfall: 'Teknisyen yola Ã§Ä±ktÄ±!',
                dringend: 'Sizi bir saat iÃ§inde arayacaÄŸÄ±z.',
                normal: 'En kÄ±sa sÃ¼rede sizinle iletiÅŸime geÃ§eceÄŸiz.'
            },
            en: {
                created: (jobNum) => `Your job ${jobNum} has been created.`,
                notfall: 'A technician is already on the way!',
                dringend: 'We will call you within the next hour.',
                normal: 'We will get back to you as soon as possible.'
            }
        };

        // Submit customer info and create job via Elektro API
        async function submitCustomerInfo() {
            const name = document.getElementById('customerName').value.trim();
            const phone = document.getElementById('customerPhone').value.trim();
            const street = document.getElementById('customerStreet').value.trim();
            const zip = document.getElementById('customerZip').value.trim();
            const city = document.getElementById('customerCity').value.trim();

            // Get current UI text for the detected language
            const ui = uiText[currentLanguage] || uiText.de;

            if (!name || !zip || !city || !street) {
                alert(ui.fillRequired);
                return;
            }

            hideInfoForm();
            addMessage('system', ui.creatingJob);

            // Use backend-detected urgency (prefer over re-computing from history)
            let urgency = detectedUrgency || 'normal';
            let sourceLanguage = currentLanguage;
            let tradeCategory = detectedTrade || 'elektro';

            // Fallback: Check conversation history if backend didn't set urgency
            if (urgency === 'normal') {
                for (const msg of conversationHistory) {
                    // Only check user messages for urgency
                    if (msg.role === 'user' && msg.urgency) {
                        if (msg.urgency === 'notfall') { urgency = 'notfall'; break; }
                        if (msg.urgency === 'dringend') { urgency = 'dringend'; }
                    }
                }
            }

            // Build conversation turns for transcript storage
            // Now includes both user and assistant messages with proper roles
            const conversationTurns = conversationHistory.map((msg, idx) => ({
                turn_number: Math.floor(idx / 2) + 1,  // Turn number groups user+assistant
                role: msg.role,
                content: msg.content,
                language: msg.language || 'de',
                timestamp: msg.timestamp || new Date().toISOString()
            }));

            try {
                // Use the new Elektro API endpoint which stores transcripts
                const response = await fetch('/api/v1/elektro/jobs', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        title: 'Elektro-Auftrag',
                        description: pendingJobDescription || 'Kundenanfrage Ã¼ber Voice Demo',
                        customer_name: name,
                        customer_phone: phone,
                        trade_category: tradeCategory,
                        urgency: urgency,
                        // Flat address fields
                        address_street: street,
                        address_zip: zip,
                        address_city: city,
                        // Include language context
                        customer_notes: sourceLanguage !== 'de' ? `[${sourceLanguage.toUpperCase()}] ${pendingJobDescription}` : null,
                        // Conversation transcript for the dashboard
                        conversation_turns: conversationTurns,
                        detected_language: sourceLanguage,
                        session_id: sessionId
                    })
                });

                let createdJob;
                if (response.ok) {
                    createdJob = await response.json();
                    console.log('Job created via Elektro API:', createdJob);
                } else {
                    // Fallback to handwerk API if elektro fails
                    console.warn('Elektro API failed, trying handwerk fallback');
                    const fallbackResponse = await fetch('/api/v1/handwerk/jobs', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            title: 'Elektro-Auftrag',
                            description: pendingJobDescription || 'Kundenanfrage Ã¼ber Voice Demo',
                            customer_name: name,
                            customer_phone: phone,
                            trade_category: tradeCategory,
                            urgency: urgency,
                            address_street: street,
                            address_zip: zip,
                            address_city: city,
                            customer_notes: sourceLanguage !== 'de' ? `[${sourceLanguage.toUpperCase()}] ${pendingJobDescription}` : null
                        })
                    });

                    if (fallbackResponse.ok) {
                        createdJob = await fallbackResponse.json();
                    } else {
                        throw new Error('Both APIs failed');
                    }
                }

                addJobCreatedMessage(createdJob, sourceLanguage);

                // Build success message in the customer's language
                const msgs = successMessages[sourceLanguage] || successMessages.de;
                const successMsg = msgs.created(createdJob.job_number) + ' ' + msgs[urgency];

                speak(successMsg, sourceLanguage);

                // Reset for new conversation after job creation
                setTimeout(() => fullConversationReset(), 2000);

            } catch (error) {
                console.error('Error creating job:', error);
                const jobNumber = 'JOB-' + new Date().getFullYear() + '-' + String(Math.floor(Math.random() * 10000)).padStart(4, '0');
                addJobCreatedMessage({
                    job_number: jobNumber,
                    urgency: urgency,
                    trade_category: 'elektro'
                }, sourceLanguage);

                const msgs = successMessages[sourceLanguage] || successMessages.de;
                speak(msgs.created(jobNumber) + ' ' + msgs.normal, sourceLanguage);

                // Reset for new conversation after job creation
                setTimeout(() => fullConversationReset(), 2000);
            }
        }

        function showInfoForm() {
            console.log('Showing form');
            stopListening();
            infoOverlay.classList.add('active');
            updateStatus('ready');
        }

        function hideInfoForm() {
            console.log('Hiding form');
            infoOverlay.classList.remove('active');
            resetConversationState();
            updateStatus('ready');
        }

        function resetConversationState() {
            conversationActive = false;
            isProcessing = false;
            pendingJobDescription = '';
            conversationState = 'greeting';
            detectedUrgency = 'normal';
            detectedTrade = null;
        }

        // Full reset for starting completely fresh (e.g., after job submission)
        function fullConversationReset() {
            formShownThisSession = false;
            conversationActive = false;
            isProcessing = false;
            pendingJobDescription = '';
            conversationHistory = [];
            lastProcessedText = '';
            lastProcessedTime = 0;
            // Generate new session for fresh start
            sessionId = 'session-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            conversationState = 'greeting';
            detectedUrgency = 'normal';
            detectedTrade = null;
            updateStatus('ready');
        }

        function addMessage(type, text) {
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${type}`;
            msgDiv.textContent = text;
            chat.appendChild(msgDiv);
            chat.scrollTop = chat.scrollHeight;
        }

        // Multilingual urgency labels
        const urgencyLabelsI18n = {
            de: {
                notfall: 'ðŸš¨ NOTFALL - Sofort',
                dringend: 'âš¡ Dringend - Heute',
                normal: 'ðŸ“‹ Normal',
                title: 'Auftrag erstellt!',
                newJob: 'Neuer Auftrag'
            },
            ru: {
                notfall: 'ðŸš¨ ÐÐ’ÐÐ Ð˜Ð¯ - ÐÐµÐ¼ÐµÐ´Ð»ÐµÐ½Ð½Ð¾',
                dringend: 'âš¡ Ð¡Ñ€Ð¾Ñ‡Ð½Ð¾ - Ð¡ÐµÐ³Ð¾Ð´Ð½Ñ',
                normal: 'ðŸ“‹ ÐžÐ±Ñ‹Ñ‡Ð½Ñ‹Ð¹',
                title: 'Ð—Ð°ÐºÐ°Ð· ÑÐ¾Ð·Ð´Ð°Ð½!',
                newJob: 'ÐÐ¾Ð²Ñ‹Ð¹ Ð·Ð°ÐºÐ°Ð·'
            },
            tr: {
                notfall: 'ðŸš¨ ACÄ°L - Hemen',
                dringend: 'âš¡ Acil - BugÃ¼n',
                normal: 'ðŸ“‹ Normal',
                title: 'SipariÅŸ oluÅŸturuldu!',
                newJob: 'Yeni sipariÅŸ'
            },
            en: {
                notfall: 'ðŸš¨ EMERGENCY - Immediate',
                dringend: 'âš¡ Urgent - Today',
                normal: 'ðŸ“‹ Normal',
                title: 'Job created!',
                newJob: 'New job'
            }
        };

        function addJobCreatedMessage(jobData, language = 'de') {
            const msgDiv = document.createElement('div');
            msgDiv.className = 'message job-created';

            const labels = urgencyLabelsI18n[language] || urgencyLabelsI18n.de;

            msgDiv.innerHTML = `
                <div class="job-success-icon">âœ…</div>
                <div class="job-success-title">${labels.title}</div>
                <div class="job-success-number">${jobData.job_number || labels.newJob}</div>
                <div class="job-success-meta">
                    ${labels[jobData.urgency] || ''} â€¢ Elektro
                </div>
            `;
            chat.appendChild(msgDiv);
            chat.scrollTop = chat.scrollHeight;
        }

        // TTS Audio element for backend TTS playback
        let currentAudioElement = null;

        // Speak text using backend TTS API (high-quality natural voice)
        async function speak(text, language = 'de') {
            // Cancel any ongoing speech
            stopSpeaking();

            isSpeaking = true;
            speakingIndicator.classList.add('active');

            try {
                // Call backend TTS endpoint
                const response = await fetch('/api/v1/audio/tts', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        text: text,
                        language: language
                    })
                });

                if (!response.ok) {
                    throw new Error(`TTS request failed: ${response.status}`);
                }

                const ttsEngine = response.headers.get('X-TTS-Engine') || 'unknown';
                const contentType = response.headers.get('Content-Type') || 'audio/mpeg';
                console.log(`Using TTS engine: ${ttsEngine} (${contentType}) for language: ${language}`);

                // Get audio data as blob
                const audioBlob = await response.blob();

                if (audioBlob.size === 0) {
                    console.warn('Empty TTS response, falling back to browser TTS');
                    fallbackSpeak(text, language);
                    return;
                }

                // Create audio URL and play with Audio element
                // This handles both MP3 (ElevenLabs) and WAV (Piper) formats
                const audioUrl = URL.createObjectURL(audioBlob);
                currentAudioElement = new Audio(audioUrl);

                currentAudioElement.onended = () => {
                    isSpeaking = false;
                    speakingIndicator.classList.remove('active');
                    URL.revokeObjectURL(audioUrl);
                    currentAudioElement = null;
                };

                currentAudioElement.onerror = (e) => {
                    console.error('Audio playback error:', e);
                    isSpeaking = false;
                    speakingIndicator.classList.remove('active');
                    URL.revokeObjectURL(audioUrl);
                    currentAudioElement = null;
                    fallbackSpeak(text, language);
                };

                await currentAudioElement.play();

            } catch (error) {
                console.error('Backend TTS failed, falling back to browser TTS:', error);
                fallbackSpeak(text, language);
            }
        }

        // Stop any currently playing TTS audio
        function stopSpeaking() {
            if (currentAudioElement) {
                try {
                    currentAudioElement.pause();
                    currentAudioElement.currentTime = 0;
                } catch (e) {}
                currentAudioElement = null;
            }
            // Also stop browser TTS if it was used as fallback
            if (synth) {
                synth.cancel();
            }
            isSpeaking = false;
            speakingIndicator.classList.remove('active');

            // Don't reset to 'ready' here - let the caller decide
            // This prevents status flickering during transitions
        }

        // Fallback to browser TTS if backend fails
        function fallbackSpeak(text, language = 'de') {
            if (!synth) {
                isSpeaking = false;
                speakingIndicator.classList.remove('active');
                return;
            }

            const langCodeMap = {
                de: 'de-DE',
                ru: 'ru-RU',
                tr: 'tr-TR',
                en: 'en-US'
            };

            const utterance = new SpeechSynthesisUtterance(text);
            const langCode = langCodeMap[language] || 'de-DE';
            utterance.lang = langCode;
            utterance.rate = 1.0;
            utterance.pitch = 1.0;

            const voices = synth.getVoices();
            const targetVoice = voices.find(v => v.lang.startsWith(langCode.split('-')[0]));
            if (targetVoice) {
                utterance.voice = targetVoice;
            }

            utterance.onend = () => {
                isSpeaking = false;
                speakingIndicator.classList.remove('active');
            };

            utterance.onerror = () => {
                isSpeaking = false;
                speakingIndicator.classList.remove('active');
            };

            synth.speak(utterance);
        }

        function toggleRecording() {
            // Stop any ongoing speech first
            if (isSpeaking) {
                stopSpeaking();
            }

            if (isRecording) {
                // User wants to stop
                stopListening();
                conversationActive = false;
                stopRecording();
            } else {
                // User wants to start
                if (!recognition) {
                    if (!initSpeechRecognition()) return;
                }
                startListening();
            }
        }

        function stopRecording() {
            isRecording = false;
            micBtn.classList.remove('recording');
            micIcon.textContent = 'ðŸŽ¤';
            micHint.textContent = conversationActive ? 'Ich hÃ¶re gleich wieder...' : 'Zum Sprechen tippen';
            micHint.classList.remove('recording');

            if (!isSpeaking && !isProcessing) {
                updateStatus('ready');
            }
        }

        // Event listeners
        micBtn.addEventListener('click', toggleRecording);

        let holdTimeout;
        micBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            holdTimeout = setTimeout(() => {
                if (!isRecording && !isSpeaking) {
                    toggleRecording();
                }
            }, 100);
        }, { passive: false });

        micBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            clearTimeout(holdTimeout);
        }, { passive: false });

        if (synth) {
            synth.onvoiceschanged = () => {
                const voices = synth.getVoices();
                console.log('Available German voices:', voices.filter(v => v.lang.startsWith('de')).map(v => v.name));
            };
        }

        document.addEventListener('DOMContentLoaded', () => {
            if (initSpeechRecognition()) {
                document.getElementById('statusText').textContent = 'Bereit';
            } else {
                document.getElementById('statusText').textContent = 'Nicht unterstÃ¼tzt';
                document.getElementById('statusDot').style.background = '#fb7185';
            }
        });
    </script>
</body>
</html>
